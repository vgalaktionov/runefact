{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and Core Infrastructure",
        "description": "Initialize the Go module, set up the project directory structure, and implement the core configuration system including runefact.toml parsing and CLI scaffolding.",
        "details": "1. Initialize Go module: `go mod init github.com/runefact/runefact`\n2. Create directory structure:\n   - cmd/runefact/ (CLI entry point)\n   - internal/config/ (configuration parsing)\n   - internal/palette/, internal/sprite/, internal/tilemap/\n   - internal/instrument/, internal/sfx/, internal/track/\n   - internal/audio/, internal/manifest/, internal/preview/, internal/watcher/, internal/mcp/\n3. Implement config package:\n   - Define ProjectConfig struct matching runefact.toml schema\n   - Use github.com/BurntSushi/toml or github.com/pelletier/go-toml/v2 for parsing\n   - Implement FindProjectRoot() to walk up directories looking for runefact.toml\n   - Implement LoadConfig(path string) (*ProjectConfig, error)\n4. Implement CLI scaffolding using cobra or manual flag parsing:\n   - runefact build [--sprites|--maps|--audio] [files...]\n   - runefact validate [files...]\n   - runefact preview [file]\n   - runefact watch\n   - runefact init\n   - runefact mcp\n   - runefact docs\n5. Implement `runefact init` command:\n   - Scaffold project structure with assets/ subdirectories\n   - Generate default runefact.toml\n   - Create demo palette, sprite, map, instrument, sfx, and track files (Phase 1-5 demos from PRD)\n\nPseudo-code for config loading:\n```go\ntype ProjectConfig struct {\n    Project struct {\n        Name   string `toml:\"name\"`\n        Output string `toml:\"output\"`\n        Package string `toml:\"package\"`\n    } `toml:\"project\"`\n    Defaults struct {\n        SpriteSize int `toml:\"sprite_size\"`\n        SampleRate int `toml:\"sample_rate\"`\n        BitDepth   int `toml:\"bit_depth\"`\n    } `toml:\"defaults\"`\n    Preview struct {\n        WindowWidth  int     `toml:\"window_width\"`\n        WindowHeight int     `toml:\"window_height\"`\n        Background   string  `toml:\"background\"`\n        PixelScale   int     `toml:\"pixel_scale\"`\n        AudioVolume  float64 `toml:\"audio_volume\"`\n    } `toml:\"preview\"`\n}\n```",
        "testStrategy": "1. Unit tests for config parsing with valid/invalid TOML inputs\n2. Test FindProjectRoot() with nested directory structures\n3. Test `runefact init` creates all expected files and directories\n4. Verify CLI commands parse flags correctly and return appropriate exit codes\n5. Test that missing runefact.toml produces clear error message with fix suggestion",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Go Module and Create Directory Structure",
            "description": "Initialize the Go module with `go mod init github.com/runefact/runefact` and create the complete project directory structure with all required packages.",
            "dependencies": [],
            "details": "1. Run `go mod init github.com/runefact/runefact` to create go.mod\n2. Create the following directory structure:\n   - cmd/runefact/ (CLI entry point with main.go placeholder)\n   - internal/config/ (configuration parsing)\n   - internal/palette/ (palette file handling)\n   - internal/sprite/ (sprite file handling)\n   - internal/tilemap/ (tilemap file handling)\n   - internal/instrument/ (instrument definitions)\n   - internal/sfx/ (sound effects)\n   - internal/track/ (music track handling)\n   - internal/audio/ (audio synthesis engine)\n   - internal/manifest/ (asset manifest generation)\n   - internal/preview/ (live preview system)\n   - internal/watcher/ (file watching)\n   - internal/mcp/ (MCP protocol support)\n3. Create placeholder .go files in each package with package declarations\n4. Add .gitkeep files to empty directories if needed\n5. Create assets/ directory structure for runefact init scaffolding reference",
            "status": "pending",
            "testStrategy": "Verify go.mod exists with correct module path. Verify all directories exist using os.Stat. Verify placeholder files have correct package declarations. Run `go build ./...` to ensure valid Go structure."
          },
          {
            "id": 2,
            "title": "Implement ProjectConfig Struct and TOML Parser",
            "description": "Define the ProjectConfig struct matching the runefact.toml schema and implement TOML parsing using a well-established library.",
            "dependencies": [
              1
            ],
            "details": "1. Add github.com/pelletier/go-toml/v2 dependency to go.mod\n2. Create internal/config/config.go with:\n   ```go\n   type ProjectConfig struct {\n       Project struct {\n           Name    string `toml:\"name\"`\n           Output  string `toml:\"output\"`\n           Package string `toml:\"package\"`\n       } `toml:\"project\"`\n       Defaults struct {\n           SpriteSize int `toml:\"sprite_size\"`\n           SampleRate int `toml:\"sample_rate\"`\n           BitDepth   int `toml:\"bit_depth\"`\n       } `toml:\"defaults\"`\n       Preview struct {\n           WindowWidth  int     `toml:\"window_width\"`\n           WindowHeight int     `toml:\"window_height\"`\n           Background   string  `toml:\"background\"`\n           PixelScale   int     `toml:\"pixel_scale\"`\n           AudioVolume  float64 `toml:\"audio_volume\"`\n       } `toml:\"preview\"`\n   }\n   ```\n3. Implement LoadConfig(path string) (*ProjectConfig, error) that:\n   - Reads the TOML file\n   - Unmarshals into ProjectConfig\n   - Validates required fields\n   - Sets sensible defaults for optional fields\n4. Add validation for output path, sprite_size > 0, sample_rate > 0, etc.",
            "status": "pending",
            "testStrategy": "Unit tests for LoadConfig with valid TOML files. Test parsing of all config sections. Test error handling for malformed TOML. Test default values are applied for missing optional fields. Test validation errors for invalid values (negative sprite_size, etc.)."
          },
          {
            "id": 3,
            "title": "Implement FindProjectRoot Directory Traversal",
            "description": "Implement FindProjectRoot() function that walks up the directory tree searching for runefact.toml to locate the project root.",
            "dependencies": [
              1
            ],
            "details": "1. Create internal/config/root.go with:\n   ```go\n   func FindProjectRoot() (string, error)\n   func FindProjectRootFrom(startDir string) (string, error)\n   ```\n2. Implementation logic:\n   - Start from current working directory (or specified startDir)\n   - Check if runefact.toml exists in current directory\n   - If found, return absolute path to that directory\n   - If not found, move to parent directory\n   - Continue until filesystem root is reached\n   - Return descriptive error if not found (ErrProjectNotFound)\n3. Add helper function IsProjectRoot(dir string) bool\n4. Add GetConfigPath() that returns full path to runefact.toml\n5. Handle symlinks appropriately using filepath.EvalSymlinks\n6. Use filepath.Abs to ensure consistent absolute path handling\n7. Define sentinel error var ErrProjectNotFound = errors.New(\"runefact.toml not found\")",
            "status": "pending",
            "testStrategy": "Test FindProjectRoot from project root returns correct path. Test from nested subdirectory finds parent runefact.toml. Test from outside any project returns ErrProjectNotFound. Test with symlinked directories. Test IsProjectRoot helper function."
          },
          {
            "id": 4,
            "title": "Implement CLI Scaffolding with Cobra",
            "description": "Create the CLI command structure using cobra library with all required commands: build, validate, preview, watch, init, mcp, and docs.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "1. Add github.com/spf13/cobra dependency\n2. Create cmd/runefact/main.go with root command setup\n3. Create cmd/runefact/root.go with:\n   - Root command with app description\n   - Persistent flags for --config, --verbose, --quiet\n   - Version command\n4. Implement command files (initially with placeholder Run functions):\n   - cmd/runefact/build.go: `runefact build [--sprites|--maps|--audio] [files...]`\n     Flags: --sprites, --maps, --audio (filter by type), positional args for specific files\n   - cmd/runefact/validate.go: `runefact validate [files...]`\n   - cmd/runefact/preview.go: `runefact preview [file]`\n   - cmd/runefact/watch.go: `runefact watch`\n   - cmd/runefact/init.go: `runefact init` (will be fully implemented in subtask 5)\n   - cmd/runefact/mcp.go: `runefact mcp`\n   - cmd/runefact/docs.go: `runefact docs`\n5. Add help text and usage examples for each command\n6. Implement proper exit codes (0=success, 1=error, 2=usage error)",
            "status": "pending",
            "testStrategy": "Test --help output for root and all subcommands. Test --version displays version info. Test invalid commands return exit code 2. Test flag parsing for build command filters. Test positional arguments are captured correctly. Test persistent flags propagate to subcommands."
          },
          {
            "id": 5,
            "title": "Implement runefact init Command with Demo File Scaffolding",
            "description": "Fully implement the `runefact init` command that scaffolds a new Runefact project with directory structure, default runefact.toml, and demo asset files.",
            "dependencies": [
              4
            ],
            "details": "1. Implement init command in cmd/runefact/init.go:\n   - Check if runefact.toml already exists (error or --force flag)\n   - Create assets/ directory structure:\n     - assets/palettes/\n     - assets/sprites/\n     - assets/maps/\n     - assets/instruments/\n     - assets/sfx/\n     - assets/tracks/\n   - Create output directory (default: generated/)\n2. Generate default runefact.toml with sensible defaults:\n   ```toml\n   [project]\n   name = \"my-game\"\n   output = \"generated\"\n   package = \"assets\"\n   \n   [defaults]\n   sprite_size = 16\n   sample_rate = 44100\n   bit_depth = 16\n   \n   [preview]\n   window_width = 800\n   window_height = 600\n   background = \"#1a1a2e\"\n   pixel_scale = 4\n   audio_volume = 0.8\n   ```\n3. Create demo files (matching PRD Phase 1-5 examples):\n   - assets/palettes/default.palette (basic color palette)\n   - assets/sprites/demo.sprite (simple sprite with pixel grid)\n   - assets/maps/demo.map (small tilemap example)\n   - assets/instruments/demo.inst (basic instrument definition)\n   - assets/sfx/demo.sfx (simple sound effect)\n   - assets/tracks/demo.track (basic music pattern)\n4. Add --name flag to customize project name\n5. Print summary of created files on success",
            "status": "pending",
            "testStrategy": "Test init creates all expected directories. Test runefact.toml is created with correct content. Test all demo files are created with valid syntax. Test --force overwrites existing files. Test --name customizes project name. Test error when runefact.toml exists without --force. Test file permissions are correct."
          }
        ]
      },
      {
        "id": 2,
        "title": "Palette Parser and Color Resolution",
        "description": "Implement the .palette file parser that handles TOML-based color palette definitions with single-char and multi-char color keys, supporting transparent and hex color values.",
        "details": "1. Create internal/palette/palette.go:\n   - Define Palette struct with Name and Colors map[string]Color\n   - Define Color struct with R, G, B, A uint8 fields and Hex string\n2. Implement palette parsing:\n   - Parse [colors] section from TOML\n   - Handle 'transparent' keyword -> Color{0, 0, 0, 0}\n   - Parse hex colors: #RGB, #RRGGBB, #RRGGBBAA formats\n   - Support single-char keys (_, k, w, r) and multi-char keys (sk, rb, ht)\n3. Implement palette resolution:\n   - LoadPalette(path string) (*Palette, error)\n   - ResolvePalette(name string, searchPaths []string) (*Palette, error)\n4. Color utilities:\n   - ParseHexColor(hex string) (Color, error) with validation\n   - Color.ToRGBA() color.RGBA for Go image compatibility\n   - SuggestSimilarKey(unknown string, available []string) string using Levenshtein distance\n5. Error handling with line numbers:\n   - Track TOML line numbers for error reporting\n   - Format: \"palettes/default.palette:5: invalid hex color '#xyz'\"\n\nPseudo-code:\n```go\nfunc ParsePalette(content []byte, filename string) (*Palette, error) {\n    var raw struct {\n        Name   string            `toml:\"name\"`\n        Colors map[string]string `toml:\"colors\"`\n    }\n    if err := toml.Unmarshal(content, &raw); err != nil {\n        return nil, err\n    }\n    \n    palette := &Palette{Name: raw.Name, Colors: make(map[string]Color)}\n    for key, value := range raw.Colors {\n        if value == \"transparent\" {\n            palette.Colors[key] = Color{A: 0}\n        } else {\n            color, err := ParseHexColor(value)\n            if err != nil {\n                return nil, fmt.Errorf(\"%s: invalid color for key '%s': %w\", filename, key, err)\n            }\n            palette.Colors[key] = color\n        }\n    }\n    return palette, nil\n}\n```",
        "testStrategy": "1. Unit tests for ParseHexColor with valid colors (#ff0000, #f00, #ff0000ff), invalid colors (#xyz, #12345), and edge cases\n2. Test transparent keyword handling\n3. Test single-char and multi-char key parsing\n4. Test palette resolution with multiple search paths\n5. Test error messages include file/line references\n6. Test SuggestSimilarKey returns correct suggestions (e.g., 'skn' suggests 'sk')\n7. Test demo default.palette from PRD parses correctly",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Color and Palette structs with TOML tags",
            "description": "Create the foundational data structures for representing colors and palettes in internal/palette/palette.go, including proper TOML struct tags for unmarshaling.",
            "dependencies": [],
            "details": "Create internal/palette/palette.go with:\n\n1. Color struct with R, G, B, A uint8 fields and Hex string field to store the original hex representation\n2. Palette struct with Name string and Colors map[string]Color\n3. Add a raw struct for TOML unmarshaling with `toml:` tags:\n   - Name string `toml:\"name\"`\n   - Colors map[string]string `toml:\"colors\"`\n4. Implement Color.ToRGBA() method returning color.RGBA for Go image compatibility:\n   ```go\n   func (c Color) ToRGBA() color.RGBA {\n       return color.RGBA{R: c.R, G: c.G, B: c.B, A: c.A}\n   }\n   ```\n5. Add a TransparentColor variable as a convenience: Color{0, 0, 0, 0}\n6. Add package documentation explaining the palette file format support",
            "status": "pending",
            "testStrategy": "Test Color.ToRGBA() returns correct color.RGBA values. Test that Color struct properly stores all uint8 values including edge cases (0, 255). Verify Palette struct can hold both single-char and multi-char keys in its Colors map."
          },
          {
            "id": 2,
            "title": "Implement ParseHexColor function with format validation",
            "description": "Implement ParseHexColor function that parses hex color strings in #RGB, #RRGGBB, and #RRGGBBAA formats with comprehensive validation and error reporting.",
            "dependencies": [
              1
            ],
            "details": "Implement ParseHexColor(hex string) (Color, error) in internal/palette/palette.go:\n\n1. Validate input starts with '#' character\n2. Support three hex formats:\n   - #RGB (3 chars): Expand each char to two (e.g., #F00 -> #FF0000), alpha defaults to 255\n   - #RRGGBB (6 chars): Parse directly, alpha defaults to 255\n   - #RRGGBBAA (8 chars): Parse all four components including alpha\n3. Use strconv.ParseUint with base 16 for hex parsing\n4. Validate hex characters are valid (0-9, a-f, A-F)\n5. Return descriptive errors:\n   - \"hex color must start with '#'\"\n   - \"invalid hex color length: expected 3, 6, or 8 characters after '#', got N\"\n   - \"invalid hex character 'X' in color\"\n6. Store original hex string in Color.Hex field for debugging/display\n\n```go\nfunc ParseHexColor(hex string) (Color, error) {\n    if !strings.HasPrefix(hex, \"#\") {\n        return Color{}, fmt.Errorf(\"hex color must start with '#'\")\n    }\n    h := hex[1:]\n    // handle #RGB, #RRGGBB, #RRGGBBAA\n}\n```",
            "status": "pending",
            "testStrategy": "Test valid colors: #ff0000 (red), #f00 (short red), #ff0000ff (red with alpha), #00ff0080 (semi-transparent green). Test invalid inputs: #xyz (invalid chars), #12345 (wrong length), missing # prefix, empty string, #GGG (invalid hex). Verify alpha defaults to 255 for #RGB and #RRGGBB formats."
          },
          {
            "id": 3,
            "title": "Implement ParsePalette function with transparent keyword support",
            "description": "Implement ParsePalette function that parses TOML palette files, handles the 'transparent' keyword, and builds the color map with comprehensive error handling including line numbers.",
            "dependencies": [
              2
            ],
            "details": "Implement ParsePalette(content []byte, filename string) (*Palette, error) in internal/palette/palette.go:\n\n1. Use BurntSushi/toml or pelletier/go-toml for TOML parsing\n2. Unmarshal into raw struct with Name and Colors map\n3. Iterate over colors map and process each value:\n   - If value == \"transparent\": assign Color{0, 0, 0, 0} with Hex=\"transparent\"\n   - Otherwise: call ParseHexColor and wrap errors with key context\n4. Support both single-char keys (_, k, w, r) and multi-char keys (sk, rb, ht)\n5. Include filename in all error messages for context\n6. Track line numbers for error reporting (may require custom TOML handling or post-parsing validation)\n7. Format errors as: \"palettes/default.palette:5: invalid hex color '#xyz' for key 'bg'\"\n\n```go\nfor key, value := range raw.Colors {\n    value = strings.TrimSpace(value)\n    if strings.ToLower(value) == \"transparent\" {\n        palette.Colors[key] = Color{A: 0, Hex: \"transparent\"}\n    } else {\n        color, err := ParseHexColor(value)\n        if err != nil {\n            return nil, fmt.Errorf(\"%s: key '%s': %w\", filename, key, err)\n        }\n        palette.Colors[key] = color\n    }\n}\n```",
            "status": "pending",
            "testStrategy": "Test parsing valid palette TOML with mixed single/multi-char keys. Test transparent keyword (case-insensitive). Test error messages include filename and key context. Test empty palette (no colors). Test palette with only transparent colors. Test malformed TOML produces parse error."
          },
          {
            "id": 4,
            "title": "Implement ResolvePalette and SuggestSimilarKey functions",
            "description": "Implement palette resolution with multi-path search capabilities and a Levenshtein distance-based key suggestion system for helpful error messages when unknown palette keys are encountered.",
            "dependencies": [
              3
            ],
            "details": "Implement in internal/palette/palette.go:\n\n1. LoadPalette(path string) (*Palette, error):\n   - Read file from disk using os.ReadFile\n   - Call ParsePalette with content and filename\n   - Wrap I/O errors with path context\n\n2. ResolvePalette(name string, searchPaths []string) (*Palette, error):\n   - If name is absolute path or contains path separator, load directly\n   - Otherwise search paths in order: check for name.palette and name in each directory\n   - Return first found palette or error listing all searched paths\n   - Format: \"palette 'foo' not found in: ./palettes, ~/.config/runefact/palettes\"\n\n3. SuggestSimilarKey(unknown string, available []string) string:\n   - Implement Levenshtein distance algorithm\n   - Find key with minimum distance from unknown\n   - Return suggestion only if distance <= 2 (configurable threshold)\n   - Return empty string if no close match\n   - Usage in errors: \"unknown palette key 'blu', did you mean 'bl'?\"\n\n4. Levenshtein distance helper:\n   ```go\n   func levenshteinDistance(a, b string) int {\n       // Standard DP implementation\n   }\n   ```",
            "status": "pending",
            "testStrategy": "Test LoadPalette with valid file path. Test ResolvePalette finds palette in second search path when not in first. Test ResolvePalette error message lists all searched paths. Test SuggestSimilarKey returns 'red' for 'rad' (distance 1). Test SuggestSimilarKey returns empty for very different strings (distance > 2). Test Levenshtein distance: identical strings = 0, single char diff = 1, complete difference = max length."
          }
        ]
      },
      {
        "id": 3,
        "title": "Sprite Parser and Pixel Grid Handling",
        "description": "Implement the .sprite file parser that handles TOML sprite definitions, parses pixel grids with single-char and bracket [xx] multi-char syntax, and validates frame dimensions and palette references.",
        "details": "1. Create internal/sprite/sprite.go:\n   - Define SpriteFile struct containing palette reference, default grid size, and sprites map\n   - Define Sprite struct with Name, Grid (WxH), Framerate, and Frames []Frame\n   - Define Frame struct with Pixels [][]string (2D array of palette keys)\n2. Implement pixel grid parsing:\n   - Parse `pixels = \"\"\"...\"\"\"` multiline strings\n   - Split into rows, then parse each row:\n     - Single chars: directly append to row\n     - Bracket sequences [xx]: extract key between brackets\n   - Validate all rows have same width\n   - Return [][]string grid of palette keys\n3. Implement sprite file parsing:\n   - Parse global palette reference and grid size\n   - Parse [sprite.X] and [sprite.X.frame] sections\n   - Handle palette_extend for inline color definitions\n   - Merge palette_extend with base palette for validation\n4. Validation:\n   - All frames in an animation must have same dimensions\n   - Grid value must match actual pixel dimensions\n   - All palette keys must resolve (collect unresolved for batch error)\n   - Ragged rows are errors with line numbers\n5. Build resolved sprite data:\n   - ResolvedSprite with actual Color values for each pixel\n   - Calculate sheet layout: frames horizontal, sprites stacked vertically\n\nPseudo-code for grid parsing:\n```go\nfunc ParsePixelGrid(raw string) ([][]string, error) {\n    lines := strings.Split(strings.TrimSpace(raw), \"\\n\")\n    var grid [][]string\n    var expectedWidth int\n    \n    for lineNum, line := range lines {\n        row := []string{}\n        i := 0\n        for i < len(line) {\n            if line[i] == '[' {\n                end := strings.Index(line[i:], \"]\")\n                if end == -1 {\n                    return nil, fmt.Errorf(\"line %d: unclosed bracket\", lineNum+1)\n                }\n                key := line[i+1 : i+end]\n                row = append(row, key)\n                i += end + 1\n            } else {\n                row = append(row, string(line[i]))\n                i++\n            }\n        }\n        if lineNum == 0 {\n            expectedWidth = len(row)\n        } else if len(row) != expectedWidth {\n            return nil, fmt.Errorf(\"line %d: ragged row, expected %d, got %d\", lineNum+1, expectedWidth, len(row))\n        }\n        grid = append(grid, row)\n    }\n    return grid, nil\n}\n```",
        "testStrategy": "1. Test pixel grid parsing with single-char keys\n2. Test bracket [xx] multi-char key parsing\n3. Test ragged row detection with correct line numbers\n4. Test unclosed bracket error handling\n5. Test frame dimension mismatch detection in animations\n6. Test palette reference resolution from separate .palette file\n7. Test palette_extend merging with base palette\n8. Test demo player.sprite, tiles.sprite, and enemies.sprite parse correctly\n9. Test grid size validation (16 pixels expected, 14 actual = error)",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define SpriteFile, Sprite, and Frame Struct Definitions with TOML Tags",
            "description": "Create the core data structures in internal/sprite/sprite.go that represent parsed sprite files, individual sprites, and animation frames with proper TOML unmarshaling support.",
            "dependencies": [],
            "details": "Create internal/sprite/sprite.go with the following structs:\n\n1. SpriteFile struct:\n   - Palette string `toml:\"palette\"` - reference to .palette file\n   - Grid string `toml:\"grid\"` - default grid size like \"16x16\"\n   - Sprites map[string]*Sprite - populated from [sprite.X] sections\n\n2. Sprite struct:\n   - Name string - sprite identifier from section name\n   - Grid string `toml:\"grid\"` - optional override of default grid\n   - Framerate int `toml:\"fps\"` - animation speed, default 12\n   - Frames []*Frame - parsed from [[sprite.X.frame]] sections\n   - PaletteExtend map[string]string `toml:\"palette_extend\"` - inline color definitions\n\n3. Frame struct:\n   - Pixels [][]string - 2D grid of palette keys (populated by grid parser)\n   - RawPixels string `toml:\"pixels\"` - raw multiline string from TOML\n\nInclude helper methods:\n- ParseGridSize(s string) (width, height int, err error) - parses \"WxH\" format\n- (f *Frame) Width() int and Height() int accessors\n\nUse BurntSushi/toml for parsing with custom unmarshaling for the nested sprite/frame structure.",
            "status": "pending",
            "testStrategy": "Test struct field tags parse correctly from sample TOML. Test ParseGridSize with valid inputs (\"16x16\", \"8x32\"), invalid inputs (\"16\", \"axb\", \"\"), and edge cases. Test that Sprite.Frames correctly captures multiple [[sprite.X.frame]] sections."
          },
          {
            "id": 2,
            "title": "Implement Pixel Grid Parser with Single-Char and Bracket Syntax",
            "description": "Build the ParsePixelGrid function that parses multiline pixel strings, handling both single-character palette keys and multi-character [xx] bracket notation.",
            "dependencies": [
              1
            ],
            "details": "Create ParsePixelGrid(raw string, lineOffset int) ([][]string, error) in internal/sprite/parser.go:\n\n1. Trim leading/trailing whitespace from raw string\n2. Split into lines, tracking absolute line numbers using lineOffset parameter\n3. For each line, parse character by character:\n   - If char is '[': find closing ']', extract key between brackets\n     - If no closing ']' found, return error with line number: \"line %d: unclosed bracket at position %d\"\n     - Extract multi-char key (e.g., [sk] -> \"sk\")\n   - Otherwise: treat single char as key (e.g., 'k' -> \"k\")\n   - Append key to current row slice\n4. After parsing each row, validate width matches first row\n   - If mismatch: return error \"line %d: expected width %d, got %d (ragged row)\"\n5. Return 2D slice [][]string where each inner slice is a row of palette keys\n\nHandle edge cases:\n- Empty brackets [] should error: \"line %d: empty bracket key\"\n- Whitespace handling: spaces should be treated as literal space keys\n- Empty lines within grid should error or be skipped (decide based on spec)\n\nThe lineOffset parameter enables accurate error messages when pixels span multiple sections.",
            "status": "pending",
            "testStrategy": "Test single-char grid parsing (\"kkk\\nkkk\\nkkk\"). Test bracket keys (\"[sk][sk]\\n[rb][rb]\"). Test mixed syntax (\"k[sk]k\\n[rb]w[ht]\"). Test unclosed bracket error with correct line number. Test ragged row detection. Test empty brackets error. Test whitespace as literal key."
          },
          {
            "id": 3,
            "title": "Implement Frame Dimension Validation and Grid Size Verification",
            "description": "Add validation logic to ensure all frames within an animation have consistent dimensions and that parsed pixel grids match declared grid sizes.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create validation functions in internal/sprite/validate.go:\n\n1. ValidateFrameDimensions(sprite *Sprite) error:\n   - Get declared grid size from sprite.Grid (or file default)\n   - Parse grid string to get expected width/height\n   - For each frame in sprite.Frames:\n     - Compare frame.Height() to expected height\n     - Compare frame.Width() to expected width\n     - If mismatch: return error \"frame %d: grid declares %dx%d but pixels are %dx%d\"\n   - Ensure all frames have identical dimensions to first frame:\n     - If mismatch: return error \"frame %d: dimensions %dx%d don't match frame 0 (%dx%d)\"\n\n2. ValidateSpriteFile(file *SpriteFile) []error:\n   - Iterate all sprites in file\n   - Collect all validation errors (don't fail on first)\n   - Return slice of errors for batch reporting\n\n3. Add validation hook in parsing flow:\n   - After parsing all frames, call ValidateFrameDimensions\n   - Aggregate errors with sprite/frame context\n\nError messages should include:\n- Sprite name for context\n- Frame index (0-based or 1-based, be consistent)\n- Expected vs actual dimensions",
            "status": "pending",
            "testStrategy": "Test valid animation with consistent frame sizes passes. Test frame dimension mismatch detection (frame 0 is 16x16, frame 1 is 16x15). Test grid size vs actual pixels mismatch. Test error messages include sprite name and frame index. Test batch error collection returns all issues."
          },
          {
            "id": 4,
            "title": "Implement palette_extend Handling and Base Palette Merging",
            "description": "Add support for inline palette_extend definitions in sprites that extend or override the base palette, merging them for validation and rendering.",
            "dependencies": [
              1
            ],
            "details": "Create palette extension logic in internal/sprite/palette.go:\n\n1. MergePalettes(base *palette.Palette, extend map[string]string) (*palette.Palette, error):\n   - Create new Palette copying all colors from base\n   - For each key/value in extend:\n     - Parse color value using palette.ParseHexColor or handle 'transparent'\n     - Add to merged palette (overwriting if key exists in base)\n   - Return merged palette\n\n2. Update sprite parsing flow:\n   - After loading base palette from file reference\n   - For each sprite with palette_extend:\n     - Call MergePalettes to create sprite-specific palette\n     - Store merged palette reference on Sprite struct\n   - Sprites without palette_extend use base palette directly\n\n3. Handle parsing of palette_extend TOML section:\n   - Map[string]string where keys are palette keys, values are hex colors\n   - Example: palette_extend = { ht = \"#ff0000\", custom = \"#00ff00\" }\n\n4. Add Sprite.GetPalette() method that returns merged or base palette\n\nThis enables sprites to define custom colors inline without modifying the base palette file.",
            "status": "pending",
            "testStrategy": "Test palette_extend adds new keys to base palette. Test palette_extend overrides existing base keys. Test invalid hex in palette_extend produces clear error. Test sprite without palette_extend uses base palette unchanged. Test multiple sprites can have different extensions."
          },
          {
            "id": 5,
            "title": "Implement Cross-File Palette Resolution and Unknown Key Collection",
            "description": "Build the palette key validation system that resolves all pixel keys against the merged palette and collects unknown keys for batch error reporting.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Create key resolution logic in internal/sprite/resolve.go:\n\n1. ValidatePaletteKeys(sprite *Sprite, palette *palette.Palette) []KeyError:\n   - KeyError struct: { Key string, FrameIndex int, Row int, Col int }\n   - Iterate all frames in sprite\n   - For each pixel key in frame.Pixels:\n     - Check if key exists in palette.Colors\n     - If not found, add KeyError with position info\n   - Return all errors (don't fail on first)\n\n2. CollectAllKeyErrors(file *SpriteFile, basePalette *palette.Palette) map[string][]KeyError:\n   - Map keyed by sprite name\n   - For each sprite, get merged palette (with palette_extend)\n   - Call ValidatePaletteKeys\n   - Collect all unknown keys with full context\n\n3. FormatKeyErrors(errors map[string][]KeyError) string:\n   - Format batch errors for user-friendly output:\n     - \"sprite 'player': unknown palette key 'zz' at frame 0, row 2, col 5\"\n     - \"sprite 'enemy': unknown palette key 'xx' at frame 1, row 0, col 0\"\n   - Group by key to show \"key 'zz' used 5 times but not defined\"\n\n4. Integration with main parsing:\n   - After all parsing complete, run validation\n   - If any key errors, return combined error message\n   - Consider warning vs error modes for development",
            "status": "pending",
            "testStrategy": "Test valid keys all resolve without errors. Test single unknown key produces error with correct position. Test multiple unknown keys collected in batch. Test palette_extend keys resolve correctly. Test error message formatting is readable. Test same key missing multiple times is grouped."
          },
          {
            "id": 6,
            "title": "Build ResolvedSprite Construction with Color Values and Sheet Layout",
            "description": "Implement the final resolution step that converts parsed sprite data with palette key references into ResolvedSprite structures containing actual RGBA Color values, and calculate sprite sheet layout metadata.",
            "dependencies": [
              3,
              4,
              5
            ],
            "details": "Create resolution and layout logic in internal/sprite/resolved.go:\n\n1. Define ResolvedSprite struct:\n   - Name string\n   - Width, Height int - frame dimensions\n   - Framerate int\n   - Frames []ResolvedFrame\n\n2. Define ResolvedFrame struct:\n   - Pixels [][]palette.Color - 2D grid of actual Color values\n\n3. ResolveSprite(sprite *Sprite, pal *palette.Palette) (*ResolvedSprite, error):\n   - Create ResolvedSprite with name, dimensions, framerate\n   - For each frame:\n     - Create ResolvedFrame with same dimensions\n     - For each pixel key, lookup in palette and store Color\n     - (Assumes validation already passed)\n   - Return resolved sprite\n\n4. ResolveSpriteFile(file *SpriteFile, basePalette *palette.Palette) ([]*ResolvedSprite, error):\n   - Run all validation first (dimensions, keys)\n   - If validation fails, return errors\n   - Resolve each sprite in file\n   - Return slice of resolved sprites\n\n5. CalculateSheetLayout(sprites []*ResolvedSprite) SheetLayout:\n   - SheetLayout struct: Width, Height int, Sprites []SpriteMetadata\n   - SpriteMetadata: Name, X, Y, FrameWidth, FrameHeight, FrameCount, FPS\n   - Calculate: width = max(sprite.FrameCount * sprite.Width)\n   - Calculate: height = sum(sprite.Height for all sprites)\n   - Assign Y offsets for vertical stacking\n\nThis provides the final data structure ready for PNG rendering.",
            "status": "pending",
            "testStrategy": "Test single sprite resolves to correct Color values. Test multi-frame sprite resolves all frames. Test sheet layout calculates correct dimensions. Test vertical stacking assigns correct Y offsets. Test frame metadata captures FPS correctly. Test transparent pixels resolve to Color{0,0,0,0}."
          }
        ]
      },
      {
        "id": 4,
        "title": "PNG Sprite Sheet Renderer",
        "description": "Implement the sprite sheet renderer that takes parsed sprite data and generates PNG sprite sheets with correct frame layout, using Go's image stdlib for rendering.",
        "details": "1. Create internal/sprite/render.go:\n   - RenderSpriteSheet(sprites []ResolvedSprite) (*image.RGBA, SpriteSheetMeta)\n   - Calculate sheet dimensions: width = max(frames * frameWidth), height = sum(spriteHeights)\n2. Implement sprite sheet layout:\n   - For each sprite, lay out frames horizontally\n   - Stack different sprites vertically in the sheet\n   - Track metadata: x, y position, frame count, fps for each sprite\n3. Pixel rendering:\n   - Create image.RGBA with calculated dimensions\n   - For each sprite, for each frame, for each pixel:\n     - Look up Color from resolved palette\n     - Set pixel using img.Set(x, y, color.RGBA{...})\n4. PNG encoding:\n   - Use image/png encoder with default compression\n   - Write to output path in build/assets/sprites/ directory\n5. Implement SpriteSheetMeta struct:\n   - Map of sprite name to {SheetPath, X, Y, W, H, Frames, FPS}\n   - Used by manifest generator\n6. Output path handling:\n   - sprites/player.sprite -> build/assets/sprites/player.png\n   - Create directories as needed\n\nPseudo-code:\n```go\nfunc RenderSpriteSheet(sprites []ResolvedSprite) (*image.RGBA, SpriteSheetMeta, error) {\n    // Calculate dimensions\n    maxWidth := 0\n    totalHeight := 0\n    for _, s := range sprites {\n        frameWidth := s.Grid.W * len(s.Frames)\n        if frameWidth > maxWidth {\n            maxWidth = frameWidth\n        }\n        totalHeight += s.Grid.H\n    }\n    \n    img := image.NewRGBA(image.Rect(0, 0, maxWidth, totalHeight))\n    meta := SpriteSheetMeta{Sprites: make(map[string]SpriteInfo)}\n    \n    y := 0\n    for _, sprite := range sprites {\n        for frameIdx, frame := range sprite.Frames {\n            x := frameIdx * sprite.Grid.W\n            for py, row := range frame.Pixels {\n                for px, color := range row {\n                    img.Set(x+px, y+py, color.ToRGBA())\n                }\n            }\n        }\n        meta.Sprites[sprite.Name] = SpriteInfo{\n            X: 0, Y: y, W: sprite.Grid.W, H: sprite.Grid.H,\n            Frames: len(sprite.Frames), FPS: sprite.Framerate,\n        }\n        y += sprite.Grid.H\n    }\n    return img, meta, nil\n}\n```",
        "testStrategy": "1. Test single static sprite renders to correct PNG dimensions\n2. Test animated sprite with multiple frames lays out horizontally\n3. Test multiple sprites stack vertically in sheet\n4. Test transparent pixels (alpha=0) render correctly\n5. Test mixed sprite sizes within same file (16x16 player + 8x8 heart)\n6. Test SpriteSheetMeta contains correct positions and frame counts\n7. Golden test: render demo player.sprite and compare to expected PNG checksum\n8. Test output directory creation when it doesn't exist",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement sheet dimension calculation algorithm",
            "description": "Calculate sprite sheet dimensions by finding max width from frames and summing heights of all sprites.",
            "dependencies": [],
            "details": "Create internal/sprite/render.go with a function to calculate sheet dimensions. For width: iterate through all sprites, compute frameWidth = sprite.Grid.W * len(sprite.Frames), track the maximum. For height: sum all sprite.Grid.H values. Return these dimensions for image.RGBA creation. Handle edge cases: empty sprite list returns 0x0, single static sprite (1 frame) uses its grid dimensions directly. This calculation must be done before image allocation to avoid resizing.",
            "status": "pending",
            "testStrategy": "Test with empty sprite list returns 0x0 dimensions. Test single sprite with 1 frame returns exact grid dimensions. Test single sprite with 4 frames returns width=4*gridW. Test multiple sprites returns max width and sum of heights. Test mixed frame counts (sprite1: 3 frames, sprite2: 5 frames) correctly uses 5*gridW for width."
          },
          {
            "id": 2,
            "title": "Implement sprite sheet layout logic with metadata tracking",
            "description": "Build the layout algorithm that positions frames horizontally within each sprite row and stacks sprites vertically, while generating SpriteSheetMeta.",
            "dependencies": [
              1
            ],
            "details": "Define SpriteSheetMeta struct with Sprites map[string]SpriteInfo. Define SpriteInfo struct with X, Y, W, H int, Frames int, FPS int fields. Implement layout in RenderSpriteSheet: maintain y offset starting at 0, for each sprite record its position in meta before advancing y += sprite.Grid.H. Each sprite's X is always 0 (left-aligned), Y is current offset. Frames are laid out at x = frameIdx * sprite.Grid.W within the sprite's row. This prepares coordinates for both pixel rendering and manifest generation.",
            "status": "pending",
            "testStrategy": "Test SpriteInfo correctly records X=0, Y=0 for first sprite. Test second sprite has Y = first sprite's height. Test Frames count matches actual frame count. Test FPS is correctly copied from sprite.Framerate. Test sprite names are correctly used as map keys. Verify layout handles sprites with different heights."
          },
          {
            "id": 3,
            "title": "Implement pixel rendering with image.RGBA and color conversion",
            "description": "Render resolved sprite pixels to image.RGBA using Go's image stdlib, converting palette colors to color.RGBA values.",
            "dependencies": [
              2
            ],
            "details": "Create image.NewRGBA(image.Rect(0, 0, width, height)) using calculated dimensions. Iterate through sprites, frames, and pixels using nested loops. For each pixel at frame[py][px], compute absolute position: absX = frameIdx*sprite.Grid.W + px, absY = spriteYOffset + py. Convert Color struct to color.RGBA{R: c.R, G: c.G, B: c.B, A: c.A} and call img.Set(absX, absY, rgba). Handle transparent pixels (A=0) which should render as transparent in the output. The ResolvedSprite input should already have Color values resolved from palette references.",
            "status": "pending",
            "testStrategy": "Test single pixel renders at correct position. Test transparent pixel (alpha=0) produces transparent output. Test full frame renders all pixels in correct grid positions. Test multi-frame sprite has frames offset correctly. Test color values are preserved exactly (no color space conversion). Verify pixel coordinates don't exceed image bounds."
          },
          {
            "id": 4,
            "title": "Implement PNG encoding and output path handling",
            "description": "Encode the rendered image.RGBA to PNG format and write to output path with proper directory creation.",
            "dependencies": [
              3
            ],
            "details": "Create function SaveSpriteSheet(img *image.RGBA, outputPath string) error. Convert input path to output: sprites/player.sprite -> build/assets/sprites/player.png. Use filepath.Dir to get parent directory, os.MkdirAll to create directories with 0755 permissions. Create output file with os.Create, defer Close. Use png.Encode(file, img) with default compression. Return wrapped errors with context about which operation failed. Export both RenderSpriteSheet and SaveSpriteSheet so callers can render without saving if needed (useful for preview server).",
            "status": "pending",
            "testStrategy": "Test output path transformation: input.sprite -> build/assets/sprites/input.png. Test directory creation when build/assets/sprites doesn't exist. Test PNG file is valid and readable by image/png.Decode. Test encoded image has correct dimensions. Test colors survive PNG round-trip encoding. Test error handling when directory creation fails (permissions). Test error handling when file creation fails."
          }
        ]
      },
      {
        "id": 5,
        "title": "Map Parser and JSON Tilemap Output",
        "description": "Implement the .map file parser that handles tileset definitions, tile layers with grid data, entity layers with coordinates, and outputs JSON tilemaps compatible with ebitengine.",
        "details": "1. Create internal/tilemap/tilemap.go:\n   - Define MapFile struct with TileSize, Tileset, and Layers\n   - Define Tileset as map[string]SpriteRef (char -> \"file:sprite\")\n   - Define TileLayer with Name, ScrollX, ScrollY, and Data [][]int\n   - Define EntityLayer with Name and Entities []Entity\n   - Define Entity with Type, X, Y, and Properties map[string]interface{}\n2. Implement map parsing:\n   - Parse [tileset] section mapping chars to sprite references\n   - Parse [layer.X] sections, detecting type (tile vs entity)\n   - For tile layers: parse pixels=\"\"\"...\"\"\" grid, map chars to tileset indices\n   - For entity layers: parse [[layer.X.entity]] arrays\n3. Tileset resolution:\n   - Validate sprite references exist (\"tiles:grass\" -> check tiles.sprite has grass sprite)\n   - Build tile index mapping: tileset char -> index in output data array\n   - Store sprite metadata (source PNG, position) for JSON output\n4. JSON output format:\n   - Match the schema from PRD: tile_size, width, height, tileset, layers\n   - Tile layers: data as 2D array of tile indices\n   - Entity layers: entities array with type, x, y, properties\n   - Write to build/assets/maps/<name>.json\n5. Validation:\n   - Unknown tileset key in layer grid -> warning\n   - Ragged rows in tile layers -> error with line number\n   - Malformed sprite reference (not \"file:name\") -> error\n\nPseudo-code:\n```go\ntype JSONTilemap struct {\n    TileSize int                    `json:\"tile_size\"`\n    Width    int                    `json:\"width\"`\n    Height   int                    `json:\"height\"`\n    Tileset  map[string]TileInfo    `json:\"tileset\"`\n    Layers   []JSONLayer            `json:\"layers\"`\n}\n\ntype JSONLayer struct {\n    Name     string        `json:\"name\"`\n    Type     string        `json:\"type\"` // \"tile\" or \"entity\"\n    ScrollX  float64       `json:\"scroll_x,omitempty\"`\n    Data     [][]int       `json:\"data,omitempty\"`     // for tile layers\n    Entities []JSONEntity  `json:\"entities,omitempty\"` // for entity layers\n}\n```",
        "testStrategy": "1. Test tileset parsing with sprite references\n2. Test tile layer grid parsing and index conversion\n3. Test entity layer parsing with properties\n4. Test JSON output matches expected schema\n5. Test unknown tileset key produces warning (not error)\n6. Test ragged rows in tile layers produce error\n7. Test sprite reference validation (existing vs non-existent sprites)\n8. Test demo level1.map produces valid JSON with all layers\n9. Test parallax scroll values preserved in output",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define MapFile, Tileset, TileLayer, EntityLayer, and Entity structs",
            "description": "Create the core data structures in internal/tilemap/tilemap.go that represent a parsed .map file including MapFile, Tileset (char to sprite reference mapping), TileLayer with scroll factors and grid data, EntityLayer containing Entity objects, and Entity with type, coordinates, and properties.",
            "dependencies": [],
            "details": "Create internal/tilemap/tilemap.go with the following struct definitions:\n\n1. MapFile struct containing TileSize int, Tileset map[string]SpriteRef, and Layers []Layer (interface or sum type for TileLayer/EntityLayer)\n2. SpriteRef struct with File and Sprite string fields parsed from 'file:sprite' format\n3. TileLayer struct with Name string, ScrollX/ScrollY float64, and Data [][]int (2D grid of tile indices)\n4. EntityLayer struct with Name string and Entities []Entity\n5. Entity struct with Type string, X/Y int coordinates, and Properties map[string]interface{}\n6. JSONTilemap, JSONLayer, TileInfo, and JSONEntity structs for output serialization with proper json tags\n\nInclude a Layer interface or use a discriminated union pattern to allow both TileLayer and EntityLayer in the same Layers slice. Add helper methods for type checking (IsTileLayer, IsEntityLayer).",
            "status": "pending",
            "testStrategy": "Write unit tests verifying struct initialization, json marshaling produces expected field names with proper omitempty behavior, and SpriteRef parsing from 'file:sprite' string format works correctly."
          },
          {
            "id": 2,
            "title": "Implement tileset section parsing with sprite reference validation",
            "description": "Parse the [tileset] TOML section that maps single characters to sprite references in 'file:sprite' format, validating that referenced sprite files and sprite names exist.",
            "dependencies": [
              1
            ],
            "details": "Implement tileset parsing in internal/tilemap/parser.go:\n\n1. Parse [tileset] section from TOML using pelletier/go-toml\n2. Iterate over key-value pairs where keys are single chars (e.g., 'g', 'w', '#') and values are 'file:sprite' strings\n3. Implement ParseSpriteRef(s string) (SpriteRef, error) that:\n   - Validates format contains exactly one colon\n   - Splits into file and sprite name\n   - Returns error for malformed references (not 'file:name' format)\n4. Build tileset index mapping: assign sequential indices (0, 1, 2...) to each tileset character for use in tile layer data output\n5. Validate sprite references exist by checking that the referenced .sprite file contains the named sprite (requires LoadSprite from task 3)\n6. Store sprite metadata (source PNG position from sprite parsing) for JSON tileset output\n\nReturn descriptive errors including line numbers for malformed sprite references.",
            "status": "pending",
            "testStrategy": "Test parsing valid tileset with multiple char-to-sprite mappings, test malformed sprite references (missing colon, empty parts) produce errors, test validation catches non-existent sprite files and sprite names."
          },
          {
            "id": 3,
            "title": "Implement tile layer grid parsing with char-to-index mapping",
            "description": "Parse [layer.X] sections for tile layers, reading the pixels triple-quoted grid data, mapping tileset characters to indices, detecting ragged rows, and handling unknown tileset keys as warnings.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement tile layer parsing in internal/tilemap/parser.go:\n\n1. Detect tile layers by presence of pixels='''...''' field in [layer.X] section\n2. Parse layer metadata: Name from section name, ScrollX/ScrollY float64 values (default 1.0)\n3. Parse pixels multiline string:\n   - Split by newlines, trim empty leading/trailing lines\n   - For each row, iterate character by character\n   - Look up each char in tileset index mapping\n   - Unknown tileset key -> emit warning (not error) and use index -1 or skip\n4. Validate grid consistency:\n   - Check all rows have same length (ragged rows -> error with line number)\n   - Store Data as [][]int where each int is the tileset index\n5. Calculate width/height from grid dimensions\n6. Track and report unknown tileset characters encountered during parsing\n\nReuse patterns from sprite pixel grid parsing (task 3) for multiline string handling.",
            "status": "pending",
            "testStrategy": "Test parsing valid tile layer grid produces correct 2D int array, test ragged rows produce error with line number, test unknown tileset character produces warning but continues parsing, test ScrollX/ScrollY defaults and explicit values."
          },
          {
            "id": 4,
            "title": "Implement entity layer parsing with TOML array sections and properties",
            "description": "Parse [layer.X] sections for entity layers containing [[layer.X.entity]] TOML array entries, extracting entity type, x/y coordinates, and arbitrary properties map.",
            "dependencies": [
              1
            ],
            "details": "Implement entity layer parsing in internal/tilemap/parser.go:\n\n1. Detect entity layers by presence of [[layer.X.entity]] subsections (TOML array of tables)\n2. Parse layer metadata: Name from section name (X portion), no scroll factors for entity layers\n3. For each [[layer.X.entity]] entry:\n   - Extract required 'type' string field\n   - Extract required 'x' and 'y' integer coordinates\n   - Collect remaining fields into Properties map[string]interface{}\n   - Handle various property types: strings, ints, floats, bools, arrays\n4. Build EntityLayer with parsed Entities slice\n5. Validate required fields present:\n   - Missing 'type' -> error\n   - Missing 'x' or 'y' -> error\n   - Invalid coordinate types -> error with entity index\n\nExample entity: [[layer.enemies.entity]]\\ntype = 'goblin'\\nx = 128\\ny = 64\\npatrol_radius = 32",
            "status": "pending",
            "testStrategy": "Test parsing entity layer with multiple entities, test required fields (type, x, y) validation, test various property types are preserved in Properties map, test error messages identify which entity has issues."
          },
          {
            "id": 5,
            "title": "Implement JSON tilemap output generation matching specified schema",
            "description": "Generate JSON output from parsed MapFile matching the PRD schema with tile_size, width, height, tileset metadata, and layers array containing both tile and entity layer types, writing to build/assets/maps/<name>.json.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Implement JSON output in internal/tilemap/output.go:\n\n1. Create WriteJSON(mapFile *MapFile, outputPath string) error function\n2. Build JSONTilemap struct:\n   - tile_size: from MapFile.TileSize\n   - width/height: calculated from tile layer dimensions (or explicit if specified)\n   - tileset: map of char -> TileInfo with source PNG and sprite position metadata\n3. Convert each layer to JSONLayer:\n   - For TileLayer: type='tile', include scroll_x, scroll_y (if != 1.0), data as [][]int\n   - For EntityLayer: type='entity', include entities array\n4. Convert entities to JSONEntity with type, x, y, and properties\n5. Use json.MarshalIndent for readable output\n6. Ensure output directory exists (build/assets/maps/)\n7. Write to <name>.json where name is derived from input filename\n\nJSON should use snake_case field names via struct tags. Use omitempty for optional fields like scroll_x when equal to default.",
            "status": "pending",
            "testStrategy": "Test JSON output matches expected schema structure, test tile layers include data array and optional scroll factors, test entity layers include entities with all properties, test output file is written to correct path, test JSON is valid and parseable."
          }
        ]
      },
      {
        "id": 6,
        "title": "Go Manifest Generator",
        "description": "Implement the manifest.go generator that produces a type-safe Go package with constants and metadata for all compiled assets (sprites, maps, audio), enabling ebitengine integration.",
        "details": "1. Create internal/manifest/manifest.go:\n   - Define ManifestData struct aggregating all asset metadata\n   - Define SpriteInfo, MapInfo, AudioInfo structs for each asset type\n2. Implement code generation:\n   - Generate package declaration with configured name\n   - Generate sprite sheet path constants (SpriteSheetPlayer, etc.)\n   - Generate Sprites map[string]SpriteInfo with all sprite metadata\n   - Generate map path constants (MapLevel1, etc.)\n   - Generate audio path constants (SFXJump, TrackTheme, etc.)\n3. Code generation template:\n   - Use text/template for generating Go code\n   - Include \"DO NOT EDIT\" header\n   - Generate proper Go identifiers from asset names (kebab-case -> PascalCase)\n4. Naming conventions:\n   - Sprite sheet: file name -> SpriteSheet + PascalCase(name)\n   - Sprite entry: \"file:sprite\" key in Sprites map\n   - Map: file name -> Map + PascalCase(name)\n   - SFX: file name -> SFX + PascalCase(name)\n   - Track: file name -> Track + PascalCase(name)\n5. Write to configured output directory:\n   - Default: build/assets/manifest.go\n   - Create parent directories as needed\n\nPseudo-code for template:\n```go\nconst manifestTemplate = `// Code generated by runefact. DO NOT EDIT.\npackage {{.Package}}\n\n// Sprite sheets\nconst (\n{{range .SpriteSheets}}\t{{.Const}} = \"{{.Path}}\"\n{{end}})\n\n// Sprite metadata\ntype SpriteInfo struct {\n\tSheet   string\n\tX, Y    int\n\tW, H    int\n\tFrames  int\n\tFPS     int\n}\n\nvar Sprites = map[string]SpriteInfo{\n{{range .Sprites}}\t\"{{.Key}}\": {{{.Sheet}}, {{.X}}, {{.Y}}, {{.W}}, {{.H}}, {{.Frames}}, {{.FPS}}},\n{{end}}}\n\n// Maps\nconst (\n{{range .Maps}}\t{{.Const}} = \"{{.Path}}\"\n{{end}})\n\n// Audio\nconst (\n{{range .Audio}}\t{{.Const}} = \"{{.Path}}\"\n{{end}})\n`\n```",
        "testStrategy": "1. Test PascalCase conversion: player -> Player, game-over -> GameOver\n2. Test generated manifest compiles as valid Go code\n3. Test sprite entries match actual PNG positions\n4. Test all asset types included in manifest\n5. Test package name from config is used\n6. Test output path respects config.output setting\n7. Golden test: compare generated manifest.go to expected output for demo project",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "ManifestData Aggregation from Asset Metadata",
            "description": "Define the ManifestData struct and supporting types (SpriteInfo, MapInfo, AudioInfo) that aggregate all compiled asset metadata from sprite sheets, maps, and audio files.",
            "dependencies": [],
            "details": "Create internal/manifest/manifest.go with:\n1. SpriteInfo struct containing Sheet (string), X, Y, W, H (int), Frames (int), FPS (int)\n2. MapInfo struct with path and any relevant map metadata from the tiled output\n3. AudioInfo struct with path and type (SFX vs Track)\n4. ManifestData struct aggregating:\n   - Package string (configured package name)\n   - SpriteSheets []struct{Const, Path string} for sprite sheet constants\n   - Sprites []struct{Key string; SpriteInfo} for the Sprites map entries\n   - Maps []struct{Const, Path string} for map constants\n   - Audio []struct{Const, Path string} for audio constants\n5. NewManifestData(config *config.Config) *ManifestData constructor\n6. AddSpriteSheet(name, path string, sprites []SpriteInfo) method\n7. AddMap(name, path string) method\n8. AddAudio(name, path string, isTrack bool) method",
            "status": "pending",
            "testStrategy": "Test ManifestData construction with sample sprite, map, and audio metadata. Verify all fields populated correctly. Test AddSpriteSheet correctly associates sprites with their sheet. Test empty manifest handles edge cases gracefully."
          },
          {
            "id": 2,
            "title": "Name Conversion Utilities",
            "description": "Implement utility functions to convert asset file names and identifiers to valid Go constant names using PascalCase conventions.",
            "dependencies": [
              1
            ],
            "details": "Create internal/manifest/naming.go with:\n1. ToPascalCase(s string) string - converts kebab-case, snake_case, or mixed case to PascalCase:\n   - Split on hyphens, underscores, spaces\n   - Capitalize first letter of each segment\n   - Handle edge cases: numbers, acronyms, empty strings\n   - Examples: 'player' -> 'Player', 'game-over' -> 'GameOver', 'level_01' -> 'Level01'\n2. SpriteSheetConst(filename string) string - returns 'SpriteSheet' + ToPascalCase(name without extension)\n3. MapConst(filename string) string - returns 'Map' + ToPascalCase(name without extension)\n4. SFXConst(filename string) string - returns 'SFX' + ToPascalCase(name without extension)\n5. TrackConst(filename string) string - returns 'Track' + ToPascalCase(name without extension)\n6. SpriteKey(sheetName, spriteName string) string - returns 'sheetName:spriteName' format for Sprites map key\n7. Ensure generated identifiers are valid Go identifiers (no leading digits, only alphanumeric + underscore)",
            "status": "pending",
            "testStrategy": "Test ToPascalCase with: 'player' -> 'Player', 'game-over' -> 'GameOver', 'enemy_boss' -> 'EnemyBoss', '01-intro' -> 'Intro01' or handle leading digits. Test each const generator with various file names. Test invalid characters are stripped or replaced."
          },
          {
            "id": 3,
            "title": "Go Code Template Definition",
            "description": "Define the text/template for generating the manifest.go file with proper Go syntax for constants, structs, and map literals.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create internal/manifest/template.go with:\n1. Define manifestTemplate as a const string using text/template syntax\n2. Template structure:\n   - '// Code generated by runefact. DO NOT EDIT.' header comment\n   - 'package {{.Package}}' declaration\n   - Sprite sheet const block: 'const ( {{range .SpriteSheets}}\\n\\t{{.Const}} = \"{{.Path}}\"{{end}}\\n)'\n   - SpriteInfo struct type definition with Sheet, X, Y, W, H, Frames, FPS fields\n   - Sprites map variable: 'var Sprites = map[string]SpriteInfo{ {{range .Sprites}}\\n\\t\"{{.Key}}\": {...},{{end}}\\n}'\n   - Maps const block with path constants\n   - Audio const block with path constants (both SFX and Track prefixes)\n3. Handle empty sections gracefully (don't emit empty const blocks)\n4. Use proper Go formatting with tabs for indentation\n5. Create GenerateManifest(data *ManifestData) ([]byte, error) function that executes template",
            "status": "pending",
            "testStrategy": "Test template execution produces syntactically valid Go code. Parse generated output with go/parser to verify compilation. Test empty manifest generates minimal valid package. Test all asset types render correctly. Test special characters in paths are properly escaped."
          },
          {
            "id": 4,
            "title": "File Writing with Directory Creation",
            "description": "Implement the file writing logic that outputs the generated manifest.go to the configured output directory, creating parent directories as needed.",
            "dependencies": [
              3
            ],
            "details": "Add to internal/manifest/manifest.go:\n1. WriteManifest(data *ManifestData, outputPath string) error function:\n   - Call GenerateManifest(data) to get generated code bytes\n   - Run generated code through go/format.Source() to ensure proper formatting\n   - Extract directory from outputPath using filepath.Dir()\n   - Create parent directories with os.MkdirAll(dir, 0755)\n   - Write file with os.WriteFile(outputPath, formatted, 0644)\n   - Return descriptive errors wrapping underlying failures\n2. Default output path: 'build/assets/manifest.go' (from config.OutputDir + '/manifest.go')\n3. Validate outputPath ends with .go extension\n4. Add Generate(config *config.Config, spriteSheets []CompiledSpriteSheet, maps []CompiledMap, audio []CompiledAudio) error as the main entry point that:\n   - Creates ManifestData from config\n   - Populates with all compiled assets\n   - Calls WriteManifest with configured output path",
            "status": "pending",
            "testStrategy": "Test WriteManifest creates parent directories that don't exist. Test generated file is properly formatted Go code (verify with go/format). Test file permissions are correct. Test error handling for permission denied, invalid paths. Integration test: generate manifest, then 'go build' the output to verify it compiles."
          }
        ]
      },
      {
        "id": 7,
        "title": "Build Command and Validation Pipeline",
        "description": "Implement the `runefact build` and `runefact validate` commands with incremental compilation, proper error aggregation, and support for building specific asset types or files.",
        "details": "1. Create internal/build/build.go:\n   - Define BuildOptions struct: Scope (all/sprites/maps/audio), Files []string, OutputDir\n   - Define BuildResult struct: Artifacts, Errors, Warnings, ManifestPath\n2. Implement asset discovery:\n   - Scan configured asset directories for rune files\n   - Group by type based on extension\n   - Support file filtering when --files specified\n3. Implement build pipeline:\n   - Phase 1: Parse all palette files (needed by sprites)\n   - Phase 2: Parse and render sprites (needed by maps)\n   - Phase 3: Parse and render maps\n   - Phase 4: Parse instruments (needed by audio)\n   - Phase 5: Render SFX and tracks\n   - Phase 6: Generate manifest\n4. Error aggregation:\n   - Continue processing on non-fatal errors to report all issues\n   - Distinguish errors (block output) from warnings (informational)\n   - Format: file:line:col: message\n5. Implement validation-only mode:\n   - `runefact validate` runs parsing without rendering\n   - Returns exit code 0 if valid, 1 if errors\n6. CLI integration:\n   - `runefact build` with --sprites, --maps, --audio flags\n   - `runefact build file1.sprite file2.map` for specific files\n   - Progress output showing files being processed\n7. Output structure:\n   - Create build/assets/ and subdirectories\n   - Write PNGs to build/assets/sprites/\n   - Write JSONs to build/assets/maps/\n   - Write WAVs to build/assets/audio/\n   - Write manifest.go to build/assets/\n\nPseudo-code:\n```go\nfunc Build(opts BuildOptions, cfg *config.ProjectConfig) (*BuildResult, error) {\n    result := &BuildResult{}\n    \n    // Load all palettes first\n    palettes := map[string]*palette.Palette{}\n    for _, f := range discoverFiles(\".palette\") {\n        p, err := palette.Load(f)\n        if err != nil {\n            result.Errors = append(result.Errors, err)\n        } else {\n            palettes[p.Name] = p\n        }\n    }\n    \n    // Build sprites\n    spriteMeta := map[string]manifest.SpriteInfo{}\n    if opts.Scope == \"all\" || opts.Scope == \"sprites\" {\n        for _, f := range discoverFiles(\".sprite\") {\n            meta, errs := buildSprite(f, palettes, opts.OutputDir)\n            result.Errors = append(result.Errors, errs...)\n            for k, v := range meta {\n                spriteMeta[k] = v\n            }\n        }\n    }\n    // ... continue for maps, audio\n    \n    return result, nil\n}\n```",
        "testStrategy": "1. Test full build with demo assets produces all expected outputs\n2. Test --sprites flag only builds sprites, not maps/audio\n3. Test specific file arguments build only those files\n4. Test validation-only mode doesn't produce outputs\n5. Test error aggregation reports all issues in one run\n6. Test exit codes: 0 on success, 1 on errors\n7. Test warnings don't cause non-zero exit\n8. Test missing runefact.toml produces helpful error\n9. Test incremental build (future: skip unchanged files)",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define BuildOptions and BuildResult structs with scope filtering",
            "description": "Create the core data structures for build configuration and results in internal/build/build.go, including scope-based filtering (all/sprites/maps/audio) and file-specific builds.",
            "dependencies": [],
            "details": "Create internal/build/build.go with:\n\n1. BuildOptions struct:\n   - Scope string: \"all\", \"sprites\", \"maps\", \"audio\" to control what gets built\n   - Files []string: specific files to build when provided (overrides Scope)\n   - OutputDir string: base output directory (default: build/assets)\n   - ValidateOnly bool: flag for validation-only mode\n\n2. BuildResult struct:\n   - Artifacts []string: list of generated file paths\n   - Errors []BuildError: fatal errors that block output\n   - Warnings []BuildWarning: non-fatal issues (informational)\n   - ManifestPath string: path to generated manifest.go\n   - Duration time.Duration: total build time\n\n3. BuildError struct:\n   - File string, Line int, Col int, Message string\n   - Error() string method returning \"file:line:col: message\" format\n\n4. BuildWarning struct (similar to BuildError)\n\n5. Helper functions:\n   - ShouldBuildType(scope string, assetType string) bool\n   - FilterFiles(files []string, extension string) []string",
            "status": "pending",
            "testStrategy": "Unit test BuildOptions validation (valid scopes, file paths). Test BuildError.Error() formats correctly as 'file:line:col: message'. Test ShouldBuildType logic for each scope value. Test FilterFiles correctly filters by extension."
          },
          {
            "id": 2,
            "title": "Implement asset discovery with directory scanning and grouping",
            "description": "Build the asset discovery system that scans configured directories for rune files, groups them by type based on extension, and supports filtering when specific files are provided.",
            "dependencies": [
              1
            ],
            "details": "Create internal/build/discovery.go with:\n\n1. DiscoveredAssets struct:\n   - Palettes []string: paths to .palette files\n   - Sprites []string: paths to .sprite files\n   - Maps []string: paths to .map files\n   - Instruments []string: paths to .instrument files\n   - SFX []string: paths to .sfx files\n   - Tracks []string: paths to .track files\n\n2. DiscoverAssets(cfg *config.ProjectConfig, opts BuildOptions) (*DiscoveredAssets, error):\n   - Read asset directories from config (sprites_dir, maps_dir, audio_dir, etc.)\n   - Use filepath.WalkDir to recursively scan each directory\n   - Group files by extension (.palette, .sprite, .map, .instrument, .sfx, .track)\n   - If opts.Files is non-empty, filter to only include those specific files\n   - Return error if specified files don't exist\n\n3. Extension-to-type mapping:\n   - Map extensions to asset categories for scope filtering\n   - .palette, .sprite -> sprites scope\n   - .map -> maps scope\n   - .instrument, .sfx, .track -> audio scope\n\n4. Validate discovered files exist and are readable",
            "status": "pending",
            "testStrategy": "Test directory scanning finds all file types. Test grouping correctly categorizes by extension. Test file filtering includes only specified files. Test error handling for non-existent files. Test recursive discovery in nested directories."
          },
          {
            "id": 3,
            "title": "Build multi-phase pipeline orchestration with dependency ordering",
            "description": "Implement the build pipeline that executes phases in correct dependency order: palettes -> sprites -> maps -> instruments -> audio -> manifest, ensuring each phase has required data from previous phases.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create internal/build/pipeline.go with:\n\n1. PipelineContext struct to pass data between phases:\n   - Palettes map[string]*palette.Palette\n   - SpriteMeta map[string]manifest.SpriteInfo\n   - MapMeta map[string]manifest.MapInfo\n   - Instruments map[string]*instrument.Instrument\n   - AudioMeta map[string]manifest.AudioInfo\n\n2. Build(opts BuildOptions, cfg *config.ProjectConfig) (*BuildResult, error):\n   - Initialize BuildResult and PipelineContext\n   - Discover assets using DiscoverAssets()\n   - Execute phases in order, passing context:\n\n3. Phase functions (each returns errors to aggregate):\n   - buildPalettes(assets, ctx) []error: Load all .palette files into ctx.Palettes\n   - buildSprites(assets, ctx, opts) []error: Parse and render sprites using ctx.Palettes, populate ctx.SpriteMeta\n   - buildMaps(assets, ctx, opts) []error: Parse and render maps using ctx.SpriteMeta, populate ctx.MapMeta\n   - buildInstruments(assets, ctx) []error: Parse instruments into ctx.Instruments\n   - buildAudio(assets, ctx, opts) []error: Render SFX and tracks using ctx.Instruments\n   - generateManifest(ctx, opts) error: Generate manifest.go from all metadata\n\n4. Progress callback for CLI output: OnProgress func(phase string, current int, total int, file string)\n\n5. Skip phases based on BuildOptions.Scope (but always load palettes if building sprites)",
            "status": "pending",
            "testStrategy": "Test phase ordering executes correctly. Test context data flows between phases. Test scope filtering skips appropriate phases. Test palette loading always runs when sprites are built. Test progress callback receives correct values."
          },
          {
            "id": 4,
            "title": "Implement error aggregation with continue-on-error behavior",
            "description": "Build the error collection system that distinguishes fatal errors from warnings, continues processing after non-fatal errors to report all issues, and formats errors with file:line:col locations.",
            "dependencies": [
              1,
              3
            ],
            "details": "Enhance internal/build/build.go and pipeline.go with:\n\n1. ErrorCollector struct:\n   - errors []BuildError\n   - warnings []BuildWarning\n   - mu sync.Mutex (for concurrent error collection)\n\n2. ErrorCollector methods:\n   - AddError(file string, line, col int, message string)\n   - AddWarning(file string, line, col int, message string)\n   - AddErrorFromErr(file string, err error): Extract line/col from error if available\n   - HasErrors() bool\n   - GetErrors() []BuildError\n   - GetWarnings() []BuildWarning\n\n3. Continue-on-error logic in each phase:\n   - Wrap parsing calls in error handling that adds to collector\n   - Continue to next file even if current file has errors\n   - Track which files succeeded for manifest generation\n\n4. Error formatting:\n   - Implement Stringer interface: \"path/file.sprite:15:8: unclosed bracket\"\n   - Support errors without position: \"path/file.sprite: palette not found\"\n   - Color-code output: red for errors, yellow for warnings (when terminal supports)\n\n5. Final error report:\n   - Sort errors by file, then line, then column\n   - Print summary: \"Build failed with N errors and M warnings\"\n   - Return appropriate error from Build() if collector.HasErrors()",
            "status": "pending",
            "testStrategy": "Test errors continue processing remaining files. Test error formatting produces 'file:line:col: message'. Test warnings don't block build completion. Test error sorting by position. Test HasErrors returns correct state. Test concurrent error collection is thread-safe."
          },
          {
            "id": 5,
            "title": "Implement validation-only mode without rendering",
            "description": "Create the validation mode that parses all asset files without rendering output, checking for syntax errors, invalid references, and dimension mismatches, returning appropriate exit codes.",
            "dependencies": [
              3,
              4
            ],
            "details": "Add validation support to build system:\n\n1. Add ValidateOnly field to BuildOptions (already planned in subtask 1)\n\n2. Create internal/build/validate.go with Validate(cfg *config.ProjectConfig) (*BuildResult, error):\n   - Calls Build() with ValidateOnly: true\n   - Returns result without generating files\n\n3. Modify phase functions to check opts.ValidateOnly:\n   - buildSprites: Parse sprite files, validate palette refs, check dimensions, but skip PNG rendering\n   - buildMaps: Parse map files, validate sprite refs, but skip JSON output\n   - buildAudio: Parse audio files, validate instrument refs, but skip WAV rendering\n   - generateManifest: Skip entirely in validate mode\n\n4. Validation checks to perform:\n   - Syntax errors (parsing failures)\n   - Missing palette references in sprites\n   - Missing sprite references in maps\n   - Missing instrument references in audio\n   - Frame dimension mismatches in animations\n   - Invalid color values in palettes\n\n5. Exit code handling:\n   - Return nil error if validation passes (exit 0)\n   - Return error if any validation errors (exit 1)\n   - Warnings alone should not cause exit 1",
            "status": "pending",
            "testStrategy": "Test validate mode parses without creating output files. Test all reference validation catches missing dependencies. Test dimension validation catches mismatches. Test exit code 0 on valid files. Test exit code 1 on any errors. Test warnings don't affect exit code."
          },
          {
            "id": 6,
            "title": "CLI integration with flags, file arguments, and progress output",
            "description": "Implement the `runefact build` and `runefact validate` CLI commands with type-specific flags (--sprites, --maps, --audio), file argument support, progress display, and proper exit code handling.",
            "dependencies": [
              4,
              5
            ],
            "details": "Add commands to cmd/runefact/:\n\n1. Create cmd/runefact/build.go:\n   - Register 'build' command with cobra\n   - Flags: --sprites, --maps, --audio (each sets scope), --output-dir\n   - Positional args: specific files to build (e.g., 'runefact build hero.sprite enemy.sprite')\n   - Mutual exclusion: flags vs positional args (warn if both provided)\n\n2. Create cmd/runefact/validate.go:\n   - Register 'validate' command\n   - Same flags as build for scope filtering\n   - Positional args for specific files\n\n3. Progress output implementation:\n   - \"[1/15] Building sprites/hero.sprite...\"\n   - \"[2/15] Building sprites/enemy.sprite...\"\n   - Use build.OnProgress callback\n   - Show phase headers: \"=== Building Sprites ===\"\n   - Final summary: \"Built 10 sprites, 5 maps, 3 audio files in 1.2s\"\n\n4. Exit code handling:\n   - os.Exit(0) on success\n   - os.Exit(1) on any errors\n   - Print error summary before exit\n\n5. Output directory structure:\n   - Create build/assets/ and subdirectories\n   - build/assets/sprites/*.png\n   - build/assets/maps/*.json\n   - build/assets/audio/*.wav\n   - build/assets/manifest.go",
            "status": "pending",
            "testStrategy": "Test --sprites flag only builds sprites. Test --maps flag only builds maps. Test --audio flag only builds audio. Test positional file args build only those files. Test progress output shows correct counts. Test exit codes match build success/failure. Test output directories created correctly."
          }
        ]
      },
      {
        "id": 8,
        "title": "Audio Synthesis Engine: Oscillators and Envelopes",
        "description": "Implement the core audio synthesis engine with waveform generators (sine, square, triangle, sawtooth, noise, pulse), ADSR envelopes, and sample generation at configurable sample rates.",
        "details": "1. Create internal/audio/oscillator.go:\n   - Define Oscillator interface with Sample(phase float64) float64\n   - Implement SineOscillator: sin(2 * phase)\n   - Implement SquareOscillator: phase < 0.5 ? 1 : -1\n   - Implement TriangleOscillator: 4 * |phase - 0.5| - 1\n   - Implement SawtoothOscillator: 2 * phase - 1\n   - Implement NoiseOscillator: rand.Float64()*2 - 1\n   - Implement PulseOscillator: phase < dutyCycle ? 1 : -1\n2. Create internal/audio/envelope.go:\n   - Define ADSR struct: Attack, Decay, Sustain, Release (all float64 seconds)\n   - Implement envelope.Level(time, noteOnDuration float64) float64\n   - Attack phase: linear ramp 0 -> 1\n   - Decay phase: linear ramp 1 -> Sustain\n   - Sustain phase: constant at Sustain level\n   - Release phase: linear ramp Sustain -> 0\n3. Create internal/audio/synth.go:\n   - Define Voice struct combining oscillator, envelope, and modulations\n   - Implement pitch calculation: freq = 440 * 2^((note-69)/12) for MIDI notes\n   - Implement pitch sweep: linear/exponential/logarithmic curves\n   - Implement vibrato: frequency modulation via LFO\n4. Sample generation:\n   - Generate samples at configured sample rate (default 44100)\n   - Voice.Sample(time float64) float64 returns amplitude [-1, 1]\n   - Combine phase accumulation with frequency for continuous waveforms\n5. Create internal/audio/filter.go:\n   - Implement simple biquad filters: lowpass, highpass, bandpass\n   - Filter with cutoff frequency and resonance parameters\n   - Support filter cutoff sweep over time\n\nPseudo-code:\n```go\ntype Voice struct {\n    Oscillator Oscillator\n    Envelope   ADSR\n    Frequency  float64\n    PitchStart float64\n    PitchEnd   float64\n    PitchCurve Curve\n    Vibrato    struct {\n        Depth float64 // semitones\n        Rate  float64 // Hz\n    }\n    Filter *BiquadFilter\n}\n\nfunc (v *Voice) Sample(time, duration float64, sampleRate int) float64 {\n    // Calculate current frequency with pitch sweep\n    t := time / duration\n    freq := interpolate(v.PitchStart, v.PitchEnd, t, v.PitchCurve)\n    \n    // Apply vibrato\n    if v.Vibrato.Depth > 0 {\n        vibrato := math.Sin(2*math.Pi*v.Vibrato.Rate*time) * v.Vibrato.Depth\n        freq *= math.Pow(2, vibrato/12)\n    }\n    \n    // Generate oscillator sample\n    phase := math.Mod(time*freq, 1.0)\n    sample := v.Oscillator.Sample(phase)\n    \n    // Apply envelope\n    sample *= v.Envelope.Level(time, duration-v.Envelope.Release)\n    \n    // Apply filter\n    if v.Filter != nil {\n        sample = v.Filter.Process(sample)\n    }\n    \n    return sample\n}\n```",
        "testStrategy": "1. Test each oscillator produces expected waveform shape\n2. Test pulse oscillator duty cycle affects waveform\n3. Test ADSR envelope phases transition correctly\n4. Test pitch sweep curves (linear, exponential, logarithmic)\n5. Test vibrato modulates frequency correctly\n6. Test filter cutoff affects frequency content\n7. Test filter cutoff sweep over time\n8. Test sample values stay within [-1, 1] range\n9. Frequency accuracy test: 440Hz sine should have period of ~100 samples at 44100Hz",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Oscillator Interface and Waveform Generators",
            "description": "Create the Oscillator interface and implement all six waveform generators: sine, square, triangle, sawtooth, noise, and pulse with configurable duty cycle.",
            "dependencies": [],
            "details": "Create internal/audio/oscillator.go with:\n1. Define Oscillator interface: Sample(phase float64) float64 where phase is normalized [0, 1)\n2. SineOscillator: return math.Sin(2 * math.Pi * phase)\n3. SquareOscillator: return 1.0 if phase < 0.5 else -1.0\n4. TriangleOscillator: return 4*math.Abs(phase-0.5) - 1\n5. SawtoothOscillator: return 2*phase - 1\n6. NoiseOscillator: return rand.Float64()*2 - 1 (use thread-safe random source)\n7. PulseOscillator: struct with DutyCycle field (0-1), return 1.0 if phase < dutyCycle else -1.0\n\nAll implementations must guarantee output in [-1, 1] range. Include constructor functions NewSineOscillator(), NewPulseOscillator(dutyCycle float64), etc. PulseOscillator should clamp dutyCycle to valid range [0.01, 0.99].",
            "status": "pending",
            "testStrategy": "Test each oscillator produces values in [-1, 1] range. Verify sine at phase 0=0, 0.25=1, 0.5=0, 0.75=-1. Verify square transitions at 0.5. Verify triangle peaks at 0 and 0.5. Verify sawtooth is linear from -1 to 1. Verify noise is random within bounds. Test pulse with various duty cycles (0.25, 0.5, 0.75) produces correct waveforms."
          },
          {
            "id": 2,
            "title": "Implement ADSR Envelope with Phase Transitions",
            "description": "Create the ADSR envelope struct with Attack, Decay, Sustain, Release parameters and implement the Level() function that correctly handles phase transitions.",
            "dependencies": [
              1
            ],
            "details": "Create internal/audio/envelope.go with:\n1. Define ADSR struct with Attack, Decay, Sustain, Release (all float64 in seconds), and SustainLevel (0-1)\n2. Implement Level(time, noteOnDuration float64) float64:\n   - Attack phase (0 to Attack): linear ramp from 0 to 1, return time/Attack\n   - Decay phase (Attack to Attack+Decay): linear ramp from 1 to SustainLevel\n   - Sustain phase (Attack+Decay to noteOnDuration): constant at SustainLevel\n   - Release phase (noteOnDuration to noteOnDuration+Release): linear ramp from SustainLevel to 0\n   - After release: return 0\n3. Handle edge cases: zero attack (instant 1), zero decay (instant sustain), zero release (instant off)\n4. Include NewADSR(attack, decay, sustain, release float64) constructor with validation\n5. Add IsComplete(time, noteOnDuration float64) bool helper",
            "status": "pending",
            "testStrategy": "Test attack phase ramps linearly from 0 to 1. Test decay phase transitions smoothly from 1 to sustain level. Test sustain holds constant value. Test release phase ramps to 0. Test edge cases: zero attack starts at 1, zero decay starts at sustain, zero release cuts off immediately. Test IsComplete returns true only after full release."
          },
          {
            "id": 3,
            "title": "Implement Voice Struct with Core Sample Generation",
            "description": "Create the Voice struct that combines oscillator and envelope, implements MIDI-to-Hz pitch calculation, and generates samples with proper phase accumulation.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create internal/audio/synth.go with:\n1. Define Voice struct: Oscillator, Envelope ADSR, BaseFrequency float64, phase float64 (internal accumulator)\n2. Implement MIDI to Hz conversion: MIDIToHz(note int) float64 = 440 * math.Pow(2, float64(note-69)/12)\n3. Implement Voice.Sample(deltaTime float64) float64:\n   - Accumulate phase: v.phase += v.BaseFrequency * deltaTime\n   - Wrap phase: v.phase = math.Mod(v.phase, 1.0)\n   - Get oscillator sample: sample := v.Oscillator.Sample(v.phase)\n   - Apply envelope: sample *= v.Envelope.Level(v.currentTime, v.noteOnDuration)\n   - Track v.currentTime += deltaTime\n   - Return clamped sample in [-1, 1]\n4. Add NoteOn(frequency float64) and NoteOff() methods\n5. Add Reset() to clear phase and time accumulators\n6. Define SampleRate constant (default 44100) and helper for delta time calculation",
            "status": "pending",
            "testStrategy": "Test MIDI note 69 (A4) converts to 440Hz. Test MIDI note 60 (C4) converts to ~261.63Hz. Test phase accumulates correctly over time. Test phase wraps at 1.0. Test envelope modulates amplitude correctly. Test NoteOn/NoteOff trigger envelope phases. Test sample output stays within [-1, 1]."
          },
          {
            "id": 4,
            "title": "Implement Pitch Sweep with Linear, Exponential, and Logarithmic Curves",
            "description": "Add pitch sweep capability to Voice with configurable start/end frequencies and interpolation curve types for smooth frequency transitions.",
            "dependencies": [
              3
            ],
            "details": "Extend internal/audio/synth.go with:\n1. Define Curve type enum: CurveLinear, CurveExponential, CurveLogarithmic\n2. Add to Voice struct: PitchStart, PitchEnd float64, PitchCurve Curve, SweepDuration float64\n3. Implement interpolation functions:\n   - Linear: start + (end-start)*t\n   - Exponential: start * math.Pow(end/start, t) for frequency ratios\n   - Logarithmic: start * math.Pow(end/start, 1-math.Pow(1-t, 2)) (slow start, fast end)\n4. Create interpolate(start, end, t float64, curve Curve) float64 function\n5. Modify Voice.Sample() to calculate current frequency using interpolate based on time/SweepDuration\n6. Handle edge cases: PitchStart == PitchEnd (no sweep), t > 1 (hold at PitchEnd)\n7. Add SetPitchSweep(start, end, duration float64, curve Curve) method",
            "status": "pending",
            "testStrategy": "Test linear interpolation is proportional to time. Test exponential interpolation creates logarithmic pitch perception (musical). Test logarithmic curve accelerates over time. Test t=0 returns start frequency, t=1 returns end frequency. Test t>1 holds at end frequency. Test no sweep when start==end. Test pitch sweep affects generated samples."
          },
          {
            "id": 5,
            "title": "Implement Vibrato Using LFO Frequency Modulation",
            "description": "Add vibrato effect to Voice using a low-frequency oscillator (LFO) to modulate pitch with configurable depth (in semitones) and rate (in Hz).",
            "dependencies": [
              3
            ],
            "details": "Extend internal/audio/synth.go with:\n1. Add Vibrato struct to Voice: Depth float64 (semitones), Rate float64 (Hz), Enabled bool\n2. Implement LFO in Voice.Sample():\n   - Calculate vibrato offset: vibratoLFO := math.Sin(2*math.Pi*v.Vibrato.Rate*v.currentTime)\n   - Convert depth to frequency multiplier: modulation := vibratoLFO * v.Vibrato.Depth\n   - Apply to frequency: freq *= math.Pow(2, modulation/12)\n3. Add SetVibrato(depth, rate float64) method\n4. Ensure vibrato is applied after pitch sweep calculation but before oscillator sampling\n5. Add separate LFO phase tracking if needed for smooth vibrato across note boundaries\n6. Support Depth=0 or Enabled=false to disable vibrato without branching in hot path\n7. Consider making LFO waveform configurable (sine default, triangle optional)",
            "status": "pending",
            "testStrategy": "Test vibrato with depth=1 semitone modulates frequency by ~5.95%. Test vibrato rate affects modulation speed. Test vibrato=0 depth produces no modulation. Test vibrato combines correctly with pitch sweep. Test LFO phase is continuous across samples. Test frequency stays positive even with extreme settings."
          },
          {
            "id": 6,
            "title": "Implement Biquad Filters with Cutoff Sweep",
            "description": "Create biquad filter implementations for lowpass, highpass, and bandpass filters with configurable cutoff frequency, resonance (Q), and support for time-varying cutoff sweep.",
            "dependencies": [
              3
            ],
            "details": "Create internal/audio/filter.go with:\n1. Define BiquadFilter struct: FilterType (Lowpass/Highpass/Bandpass), Cutoff, Resonance, SampleRate float64, and state variables (x1, x2, y1, y2)\n2. Implement coefficient calculation using standard biquad formulas:\n   - omega := 2*Pi*cutoff/sampleRate, alpha := sin(omega)/(2*Q)\n   - Calculate a0, a1, a2, b0, b1, b2 based on filter type\n3. Implement Process(sample float64) float64 using Direct Form 1:\n   - y = (b0*x + b1*x1 + b2*x2 - a1*y1 - a2*y2) / a0\n   - Update state: x2=x1, x1=x, y2=y1, y1=y\n4. Add SetCutoff(freq float64) to recalculate coefficients for sweep\n5. Add CutoffStart, CutoffEnd, CutoffCurve for automated cutoff sweep\n6. Implement filter sweep in Voice.Sample() similar to pitch sweep\n7. Add Reset() to clear filter state\n8. Clamp cutoff to valid range (20Hz to Nyquist-1)",
            "status": "pending",
            "testStrategy": "Test lowpass attenuates frequencies above cutoff. Test highpass attenuates frequencies below cutoff. Test bandpass passes frequencies around cutoff. Test resonance (Q) creates peak at cutoff. Test coefficient recalculation for cutoff sweep. Test filter state resets properly. Test output stays in [-1, 1] with reasonable inputs. Test cutoff clamping to valid range."
          }
        ]
      },
      {
        "id": 9,
        "title": "Instrument and SFX Parsers with WAV Rendering",
        "description": "Implement .inst and .sfx file parsers, multi-voice mixing, WAV file writing, and audio safety features (limiter, DC offset removal, clipping detection).",
        "details": "1. Create internal/instrument/instrument.go:\n   - Define Instrument struct matching .inst schema\n   - Parse oscillator, envelope, filter, and effects sections\n   - LoadInstrument(path string) (*Instrument, error)\n2. Create internal/sfx/sfx.go:\n   - Define SFX struct with Duration, Volume, and Voices []Voice\n   - Parse [[voice]] sections with per-voice envelope, pitch, filter\n   - Support filter cutoff_start/cutoff_end sweep\n   - LoadSFX(path string) (*SFX, error)\n3. Implement SFX rendering:\n   - RenderSFX(sfx *SFX, sampleRate int) []float64\n   - Generate samples for each voice, mix together (additive)\n   - Apply overall volume\n   - Duration determines total sample count\n4. Create internal/audio/wav.go:\n   - WriteWAV(path string, samples []float64, sampleRate, bitDepth int) error\n   - Generate RIFF/WAV header\n   - Convert float64 samples to int16 PCM\n   - Write to file\n5. Audio safety in internal/audio/safety.go:\n   - BrickwallLimiter: threshold -1dBFS, lookahead, release 50ms\n   - RemoveDCOffset: high-pass filter at 10Hz\n   - DetectClipping: count consecutive max-amplitude samples\n   - DetectNaNInf: scan for invalid samples, replace with silence\n   - PeakLevel: calculate peak dBFS\n6. Integrate safety into render pipeline:\n   - Apply DC removal\n   - Apply limiter\n   - Detect and warn on clipping\n   - Warn if any voice >6dB above mix\n\nPseudo-code:\n```go\nfunc RenderSFX(sfx *SFX, sampleRate int) ([]float64, []Warning) {\n    numSamples := int(sfx.Duration * float64(sampleRate))\n    mixed := make([]float64, numSamples)\n    warnings := []Warning{}\n    \n    for _, voice := range sfx.Voices {\n        voiceSamples := renderVoice(voice, sfx.Duration, sampleRate)\n        voicePeak := peakLevel(voiceSamples)\n        \n        for i, s := range voiceSamples {\n            mixed[i] += s\n        }\n        \n        if voicePeak > mixPeak+6 {\n            warnings = append(warnings, Warning{\"voice level too high\"})\n        }\n    }\n    \n    // Apply volume\n    for i := range mixed {\n        mixed[i] *= sfx.Volume\n    }\n    \n    // Safety processing\n    mixed = removeDCOffset(mixed, sampleRate)\n    mixed = applyLimiter(mixed, sampleRate)\n    \n    return mixed, warnings\n}\n```",
        "testStrategy": "1. Test .inst parsing with all fields\n2. Test .sfx parsing with single and multi-voice\n3. Test WAV file header format is correct\n4. Test WAV file can be played by standard audio players\n5. Test limiter prevents output exceeding 0dBFS\n6. Test DC offset removal on biased signals\n7. Test NaN/Inf detection and replacement\n8. Test clipping detection warning\n9. Test demo jump.sfx, coin.sfx, explosion.sfx render correctly\n10. Test multi-voice mixing produces expected output",
        "priority": "high",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Instrument struct and .inst file parser",
            "description": "Create the instrument package with Instrument struct matching the .inst TOML schema, including oscillator, envelope, filter, and effects sections. Implement LoadInstrument() function to parse instrument files.",
            "dependencies": [],
            "details": "Create internal/instrument/instrument.go with structs: Instrument (Name string), OscillatorConfig (Waveform string, DutyCycle float64), EnvelopeConfig (Attack, Decay, Sustain, Release float64), FilterConfig (Type string, Cutoff float64, Resonance float64), EffectsConfig (VibratoDepth, VibratoRate, PitchSweep, Distortion float64). Use github.com/pelletier/go-toml/v2 for parsing. The filter and effects sections are optional. Implement LoadInstrument(path string) (*Instrument, error) that reads and unmarshals the TOML file, validating waveform is one of: sine, square, triangle, sawtooth, noise, pulse. If waveform is 'pulse', validate duty_cycle is present and in range [0.0, 1.0].",
            "status": "pending",
            "testStrategy": "Test parsing valid .inst file with all sections. Test parsing with optional sections omitted (no filter, no effects). Test validation rejects invalid waveform values. Test pulse waveform requires valid duty_cycle. Test error handling for missing required fields and malformed TOML."
          },
          {
            "id": 2,
            "title": "Implement SFX struct and .sfx file parser with multi-voice support",
            "description": "Create the sfx package with SFX and Voice structs matching the .sfx TOML schema, supporting multiple voices with per-voice envelope, pitch sweep, filter sweep, and effects. Implement LoadSFX() function.",
            "dependencies": [],
            "details": "Create internal/sfx/sfx.go with structs: SFX (Duration, Volume float64, Voices []Voice), Voice (Waveform string, DutyCycle float64, Envelope VoiceEnvelope, Pitch *VoicePitch, Filter *VoiceFilter, Effects *VoiceEffects), VoiceEnvelope (Attack, Decay, Sustain, Release float64), VoicePitch (Start, End float64, Curve string), VoiceFilter (Type string, CutoffStart, CutoffEnd float64, Curve string), VoiceEffects (VibratoDepth, VibratoRate float64). Use go-toml/v2 with [[voice]] array syntax for multiple voices. Implement LoadSFX(path string) (*SFX, error). Validate curve types are one of: linear, exponential, logarithmic. Filter type must be: lowpass, highpass, bandpass. Pitch, filter, and effects are optional per voice.",
            "status": "pending",
            "testStrategy": "Test parsing single-voice SFX with all fields. Test parsing multi-voice SFX (explosion-style with noise + sine). Test optional fields (no pitch, no filter, no effects). Test filter cutoff sweep parameters parse correctly. Test validation rejects invalid curve types. Test error handling for missing duration/volume."
          },
          {
            "id": 3,
            "title": "Implement SFX rendering with multi-voice mixing",
            "description": "Implement the RenderSFX function that generates audio samples for each voice using Task 8's synthesis engine, mixes voices additively, applies overall volume, and returns the mixed samples with any warnings.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add RenderSFX(sfx *SFX, sampleRate int) ([]float64, []Warning) to internal/sfx/sfx.go or internal/sfx/render.go. For each voice: create oscillator from waveform type (using internal/audio/oscillator.go from Task 8), apply ADSR envelope, apply pitch sweep interpolation if present (linear/exponential/logarithmic curve), apply filter cutoff sweep if present. Generate numSamples = int(duration * sampleRate) per voice. Mix voices additively into single []float64 buffer. Track per-voice peak levels; generate Warning if any voice is >6dB above mix average. Apply overall sfx.Volume multiplier at end. Implement helper renderVoice(voice Voice, duration float64, sampleRate int) []float64 and peakLevel(samples []float64) float64 (returns dBFS).",
            "status": "pending",
            "testStrategy": "Test single voice renders correct number of samples. Test multi-voice mixing produces additive output. Test pitch sweep interpolates correctly for all three curve types. Test filter cutoff sweep applies correctly over duration. Test envelope modulates amplitude. Test volume scaling applied. Test warning generated when voice level exceeds mix by >6dB."
          },
          {
            "id": 4,
            "title": "Implement WAV file writer with RIFF header and PCM conversion",
            "description": "Create the WAV file writing capability with proper RIFF/WAV header generation, float64 to int16 PCM conversion, and file output for mono audio at configurable sample rate and bit depth.",
            "dependencies": [],
            "details": "Create internal/audio/wav.go with WriteWAV(path string, samples []float64, sampleRate, bitDepth int) error. Generate RIFF header: 'RIFF' chunk with file size, 'WAVE' format. Generate fmt subchunk: audio format=1 (PCM), numChannels=1 (mono), sample rate, byte rate (sampleRate * numChannels * bitsPerSample/8), block align, bits per sample. Generate data subchunk: 'data' chunk with PCM samples. Convert float64 [-1.0, 1.0] to int16 [-32768, 32767] with proper clamping. Handle bit depth 16 (int16) and optionally 8 (uint8). Use binary.LittleEndian for all multi-byte values. Write atomically (temp file then rename) for safety.",
            "status": "pending",
            "testStrategy": "Test WAV header is exactly 44 bytes before data. Test RIFF/WAVE/fmt/data chunks have correct chunk IDs and sizes. Test float64 samples convert to int16 correctly (0.0->0, 1.0->32767, -1.0->-32768). Test clamping of samples outside [-1,1]. Test output file can be opened by standard audio players (ffprobe/ffmpeg validation). Test sample rate and bit depth correctly written to header."
          },
          {
            "id": 5,
            "title": "Implement audio safety features and integrate into render pipeline",
            "description": "Create audio safety utilities (brickwall limiter, DC offset removal, NaN/Inf detection, clipping warning) and integrate them into the SFX render pipeline to ensure safe audio output.",
            "dependencies": [
              3,
              4
            ],
            "details": "Create internal/audio/safety.go with: BrickwallLimiter(samples []float64, sampleRate int) []float64 - threshold at -1dBFS (0.891), lookahead buffer, 50ms release time to avoid pumping. RemoveDCOffset(samples []float64, sampleRate int) []float64 - single-pole high-pass filter at 10Hz. DetectClipping(samples []float64) int - count consecutive samples at max amplitude (>0.999), return count for warning. DetectNaNInf(samples []float64) ([]float64, int) - scan for NaN/Inf, replace with 0.0, return cleaned samples and count. PeakLevel(samples []float64) float64 - calculate peak in dBFS: 20*log10(maxAbs). Integrate into RenderSFX: after mixing, apply RemoveDCOffset, then BrickwallLimiter, run DetectNaNInf, run DetectClipping and add warning if clipping detected.",
            "status": "pending",
            "testStrategy": "Test limiter prevents output exceeding 0dBFS (-1dBFS threshold). Test limiter release is smooth (no pumping artifacts). Test DC offset removal on biased signal (e.g., samples averaging 0.5). Test NaN/Inf detection finds and replaces invalid samples. Test clipping detection counts consecutive max-amplitude samples. Test PeakLevel calculates correct dBFS values. Test full render pipeline applies safety in correct order: DC removal -> limiter -> NaN check -> clipping check."
          }
        ]
      },
      {
        "id": 10,
        "title": "Music Track Parser and Sequencer",
        "description": "Implement .track file parser for tracker-style music with pattern definitions, multi-channel sequencing, per-note effects, loop support, and WAV rendering.",
        "details": "1. Create internal/track/track.go:\n   - Define Track struct: Tempo, TicksPerBeat, Loop, LoopStart, Channels, Patterns, Sequence\n   - Define Channel struct: Name, Instrument, Volume\n   - Define Pattern struct: Name, Ticks, Rows []PatternRow\n   - Define PatternRow as []Note (one per channel)\n   - Define Note struct: Type (note/sustain/silence/noteoff), Pitch, Octave, Effects\n2. Implement pattern parsing:\n   - Parse data=\"\"\"...\"\"\" multiline strings\n   - Split by | to get channel columns\n   - Parse each cell: C4, C#5, ---, ..., ^^^, or note with effects (C4 v0F)\n   - Validate column count matches channel count\n3. Implement sequencer:\n   - Process patterns in sequence order\n   - For each tick, advance all channels\n   - Track note-on/note-off state per channel\n   - Handle ---(sustain), ...(silence), ^^^(note-off)\n4. Per-note effects:\n   - v0F: velocity/volume (hex 0-F)\n   - >02: pitch slide up N semitones\n   - <02: pitch slide down N semitones\n   - ~04: vibrato depth\n   - a08: arpeggio (semitone offset)\n5. Implement rendering:\n   - Calculate samples per tick: sampleRate * 60 / tempo / ticksPerBeat\n   - For each tick, render active notes on each channel\n   - Mix channels with their volume levels\n   - Apply loop: when sequence ends, jump to loopStart pattern\n6. Integration with instruments:\n   - Load referenced .inst files\n   - Create voices from instrument definitions\n   - Handle note-off triggering envelope release\n\nPseudo-code:\n```go\nfunc RenderTrack(track *Track, instruments map[string]*Instrument, sampleRate int) ([]float64, error) {\n    samplesPerTick := sampleRate * 60 / track.Tempo / track.TicksPerBeat\n    \n    var allSamples []float64\n    channelStates := make([]ChannelState, len(track.Channels))\n    \n    for _, patternName := range track.Sequence {\n        pattern := track.Patterns[patternName]\n        for _, row := range pattern.Rows {\n            tickSamples := make([]float64, samplesPerTick)\n            \n            for chIdx, note := range row {\n                ch := track.Channels[chIdx]\n                state := &channelStates[chIdx]\n                \n                switch note.Type {\n                case NoteOn:\n                    state.StartNote(note, instruments[ch.Instrument])\n                case NoteOff:\n                    state.TriggerRelease()\n                case Sustain:\n                    // continue current note\n                case Silence:\n                    state.Stop()\n                }\n                \n                for i := range tickSamples {\n                    tickSamples[i] += state.Sample() * ch.Volume\n                }\n            }\n            allSamples = append(allSamples, tickSamples...)\n        }\n    }\n    \n    return allSamples, nil\n}\n```",
        "testStrategy": "1. Test pattern parsing with correct column/row counts\n2. Test note parsing: C4, C#5, D#3, etc.\n3. Test special symbols: ---, ..., ^^^\n4. Test per-note effects parsing: v0F, >02, ~04\n5. Test sequencer plays patterns in order\n6. Test loop functionality returns to loopStart\n7. Test tempo affects playback speed correctly\n8. Test channel volume mixing\n9. Test note-off triggers envelope release\n10. Test demo theme.track and gameover.track render correctly\n11. Test column count mismatch produces clear error",
        "priority": "high",
        "dependencies": [
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Core Track Data Structures",
            "description": "Create internal/track/track.go with all core struct definitions: Track (Tempo, TicksPerBeat, Loop, LoopStart, Channels, Patterns, Sequence), Channel (Name, Instrument, Volume), Pattern (Name, Ticks, Rows), PatternRow as []Note, and Note (Type, Pitch, Octave, Effects). Define NoteType enum constants for NoteOn, NoteOff, Sustain, and Silence.",
            "dependencies": [],
            "details": "Define Track struct with fields: Tempo int, TicksPerBeat int, Loop bool, LoopStart int, Channels []Channel, Patterns map[string]*Pattern, Sequence []string. Channel struct: Name string, Instrument string, Volume float64. Pattern struct: Name string, Ticks int, Rows []PatternRow. PatternRow type alias for []Note. Note struct: Type NoteType, Pitch string (C, C#, D, etc.), Octave int, Effects []Effect. Define NoteType as int with constants: NoteOn, NoteOff, Sustain (---), Silence (...). Effect struct: Type EffectType, Value int. EffectType constants: VolumeEffect, PitchSlideUp, PitchSlideDown, Vibrato, Arpeggio.",
            "status": "pending",
            "testStrategy": "Unit tests verifying struct instantiation with all fields, default values, and that NoteType constants have distinct values. Test that PatternRow correctly holds multiple Notes."
          },
          {
            "id": 2,
            "title": "Implement Pattern Data Parser",
            "description": "Parse pattern data from multiline strings (data=\"\"\"...\"\"\" format), splitting by | delimiter to extract channel columns, validating column count matches the number of channels defined in the track.",
            "dependencies": [
              1
            ],
            "details": "Create ParsePattern(data string, numChannels int) (*Pattern, error) function. Split multiline data by newlines to get rows. For each row, split by '|' delimiter, trimming whitespace from each cell. Validate that each row has exactly numChannels columns, returning error with line number if mismatch. Store parsed rows as PatternRow slices. Handle edge cases: empty lines (skip), trailing/leading pipes, whitespace-only cells. Return pattern with populated Rows field.",
            "status": "pending",
            "testStrategy": "Test parsing 2-channel and 4-channel patterns. Test column count validation produces errors with line numbers. Test handling of empty lines, whitespace variations, and edge cases with pipes."
          },
          {
            "id": 3,
            "title": "Implement Note Cell Parser",
            "description": "Parse individual note cells from pattern columns, recognizing note syntax (C4, C#5, Db3), special symbols (--- for sustain, ... for silence, ^^^ for note-off), and notes with inline effects.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create ParseNote(cell string) (Note, error) function. Match patterns: (1) '---' returns Sustain type, (2) '...' returns Silence type, (3) '^^^' returns NoteOff type, (4) Note pattern like 'C4', 'C#5', 'Db3' - extract pitch letter, optional sharp/flat, and octave number. Use regex or manual parsing: pitch = first 1-2 chars (letter + optional #/b), octave = remaining digits. Validate octave range 0-9. After base note, check for effect codes (space-separated or concatenated). Return Note struct with Type=NoteOn and populated Pitch, Octave fields.",
            "status": "pending",
            "testStrategy": "Test parsing C4, C#5, Db3, F#7. Test special symbols ---, ..., ^^^. Test invalid notes produce descriptive errors. Test notes with trailing effects are partially parsed (effects handled separately)."
          },
          {
            "id": 4,
            "title": "Implement Per-Note Effects Parser",
            "description": "Parse per-note effect codes attached to notes: v0F (velocity/volume), >02 (pitch slide up), <02 (pitch slide down), ~04 (vibrato depth), a08 (arpeggio). Extract effect type and hex value.",
            "dependencies": [
              1,
              3
            ],
            "details": "Create ParseEffects(effectStr string) ([]Effect, error) function. Effect codes are 3 characters: type char + 2 hex digits. Parse sequentially: 'v' prefix = VolumeEffect (value 0x00-0xFF, commonly 0-F for 0-15), '>' = PitchSlideUp, '<' = PitchSlideDown, '~' = Vibrato, 'a' = Arpeggio. Hex value parsing with strconv.ParseInt(str, 16, 0). Integrate with ParseNote to handle 'C4 v0F' or 'C#5>02~04' formats. Store effects slice in Note struct. Return error for invalid effect codes or hex values.",
            "status": "pending",
            "testStrategy": "Test v0F parses to volume=15. Test >02 parses to pitch slide up 2 semitones. Test combined effects 'C4 v0F>02'. Test invalid effect codes return errors. Test hex value range validation."
          },
          {
            "id": 5,
            "title": "Implement Channel State and Sequencer",
            "description": "Implement sequencer that processes patterns in sequence order, maintaining per-channel state (active note, envelope position), handling note-on to start notes, note-off to trigger release, sustain to continue, and silence to stop.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create ChannelState struct: ActiveNote *Note, Voice *Voice (from instrument), EnvelopePhase (attack/decay/sustain/release), EnvelopePosition float64, IsActive bool. Methods: StartNote(note Note, inst *Instrument) - create voice, reset envelope to attack; TriggerRelease() - transition to release phase; Stop() - immediately silence; Sample() float64 - generate next sample using voice and envelope. Create Sequencer struct holding []ChannelState. ProcessTick(row PatternRow, channels []Channel, instruments map[string]*Instrument) advances all channels for one tick. Handle state transitions based on NoteType.",
            "status": "pending",
            "testStrategy": "Test StartNote initializes voice and sets envelope to attack. Test TriggerRelease transitions to release phase. Test Sustain maintains current state. Test Silence stops output. Test multi-channel state independence."
          },
          {
            "id": 6,
            "title": "Implement Track Rendering with Loop Support",
            "description": "Implement RenderTrack function that calculates samples-per-tick from tempo, iterates through sequence patterns, renders each tick by mixing all channel outputs, and handles loop by jumping to loopStart when sequence ends.",
            "dependencies": [
              5
            ],
            "details": "Create RenderTrack(track *Track, instruments map[string]*Instrument, sampleRate int, maxDuration float64) ([]float64, error). Calculate samplesPerTick = sampleRate * 60 / track.Tempo / track.TicksPerBeat. Initialize channelStates slice. Loop through sequence, for each pattern iterate rows. For each row, generate samplesPerTick samples by calling Sample() on each channel state, mix with channel volume. If track.Loop is true and sequence completes, reset to track.LoopStart pattern index (not sample index). Use maxDuration to prevent infinite loop rendering. Return mixed sample buffer.",
            "status": "pending",
            "testStrategy": "Test samples-per-tick calculation for various tempos (120 BPM, 60 BPM). Test sequence plays patterns in order. Test loop jumps to correct loopStart index. Test maxDuration limits output length. Test channel volume mixing produces correct levels."
          },
          {
            "id": 7,
            "title": "Integrate with Instrument System and Track File Parser",
            "description": "Create LoadTrack function to parse .track files, resolve instrument references from .inst files, and wire up the complete rendering pipeline. Handle instrument loading errors gracefully.",
            "dependencies": [
              5,
              6
            ],
            "details": "Create LoadTrack(path string) (*Track, error) that parses .track TOML file. Extract [track] section for tempo, ticks_per_beat, loop, loop_start, sequence. Parse [[channel]] sections for name, instrument path, volume. Parse [[pattern]] sections with name, ticks, and data. Call pattern/note parsers. Create RenderTrackToSamples(trackPath string, instrumentPaths []string, sampleRate int, duration float64) that loads track and all referenced instruments, calls RenderTrack. Validate instrument references exist before rendering. Return descriptive errors for missing instruments.",
            "status": "pending",
            "testStrategy": "Test loading complete .track file with all sections. Test instrument reference resolution from channel definitions. Test error when referenced instrument file not found. Test end-to-end rendering produces valid audio samples. Test integration with WAV writing from task 9."
          }
        ]
      },
      {
        "id": 11,
        "title": "File Watcher and Live Rebuild System",
        "description": "Implement the file watching system using fsnotify that detects changes to rune files and triggers incremental rebuilds, with debouncing for batched edits.",
        "details": "1. Create internal/watcher/watcher.go:\n   - Define Watcher struct wrapping fsnotify.Watcher\n   - Watch configured asset directories recursively\n   - Filter events to only .palette, .sprite, .map, .inst, .sfx, .track files\n2. Implement debouncing:\n   - Batch events within 100ms window\n   - De-duplicate multiple events for same file\n   - Group related files (if palette changes, rebuild dependent sprites)\n3. Event handling:\n   - On file change: trigger rebuild for that file and dependents\n   - On file create: add to watch list, trigger rebuild\n   - On file delete: remove from watch list, update manifest\n   - On file rename: treat as delete + create\n4. Dependency tracking:\n   - Palette changes -> rebuild all sprites using that palette\n   - Sprite changes -> rebuild maps using those sprites\n   - Instrument changes -> rebuild SFX and tracks using that instrument\n5. Integration with build system:\n   - IncrementalBuild(changed []string) (*BuildResult, error)\n   - Only rebuild affected files, not entire project\n   - Regenerate manifest after each rebuild\n6. `runefact watch` command:\n   - Start watcher, print startup message\n   - Log each rebuild with files affected\n   - Continue running until Ctrl+C\n   - Exit code reflects last build status\n\nPseudo-code:\n```go\nfunc (w *Watcher) Start(onRebuild func([]string) error) error {\n    debouncer := NewDebouncer(100 * time.Millisecond)\n    \n    for {\n        select {\n        case event := <-w.watcher.Events:\n            if isRuneFile(event.Name) {\n                debouncer.Add(event.Name)\n            }\n        case files := <-debouncer.Output:\n            // Expand dependencies\n            affected := w.expandDependencies(files)\n            \n            log.Printf(\"Rebuilding: %v\", affected)\n            if err := onRebuild(affected); err != nil {\n                log.Printf(\"Build error: %v\", err)\n            }\n        case err := <-w.watcher.Errors:\n            log.Printf(\"Watcher error: %v\", err)\n        }\n    }\n}\n```",
        "testStrategy": "1. Test file change triggers rebuild callback\n2. Test debouncing batches rapid changes\n3. Test dependency tracking: palette change triggers sprite rebuild\n4. Test file creation adds to watch list\n5. Test file deletion updates manifest\n6. Test only affected files rebuild (not full project)\n7. Test watch command runs until interrupted\n8. Test error in one file doesn't stop watching\n9. Integration test: edit file, verify output updates within 500ms",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Watcher Struct with Recursive Directory Watching",
            "description": "Create the core Watcher struct that wraps fsnotify.Watcher and implements recursive directory watching for configured asset directories.",
            "dependencies": [],
            "details": "Create internal/watcher/watcher.go with:\n1. Define Watcher struct containing fsnotify.Watcher, watched paths map, and dependency tracker reference\n2. Implement NewWatcher(assetDirs []string) (*Watcher, error) that creates fsnotify watcher\n3. Implement watchRecursive(dir string) error that walks directory tree and adds all subdirectories to watcher\n4. Handle new directory creation by automatically adding to watch list\n5. Implement Close() to clean up fsnotify resources\n6. Store watched paths in a map for efficient lookup and management\n7. Use filepath.Walk or fs.WalkDir to discover all subdirectories on startup",
            "status": "pending",
            "testStrategy": "Test recursive watching adds all subdirectories. Test new directory creation adds to watch list. Test Close() properly releases resources. Test watching non-existent directory returns error."
          },
          {
            "id": 2,
            "title": "Implement Event Filtering for Rune File Extensions",
            "description": "Add event filtering logic that only processes changes to valid rune file types (.palette, .sprite, .map, .inst, .sfx, .track) and handles create/delete/rename events appropriately.",
            "dependencies": [
              1
            ],
            "details": "Implement event filtering in watcher:\n1. Create isRuneFile(path string) bool helper checking extensions: .palette, .sprite, .map, .inst, .sfx, .track\n2. Create getFileType(path string) AssetType returning enum for the file type\n3. Filter fsnotify events in main loop - only process matching extensions\n4. Handle fsnotify.Create: add file to tracking, trigger rebuild\n5. Handle fsnotify.Write: trigger rebuild for file\n6. Handle fsnotify.Remove: remove from tracking, update manifest\n7. Handle fsnotify.Rename: treat as Remove + Create (fsnotify sends both events)\n8. Ignore temporary files (*.tmp, .swp, ~ suffix) and hidden files",
            "status": "pending",
            "testStrategy": "Test .palette, .sprite, .map, .inst, .sfx, .track files pass filter. Test .txt, .go, .json files are ignored. Test temporary and hidden files are ignored. Test each event type (Create, Write, Remove, Rename) is handled correctly."
          },
          {
            "id": 3,
            "title": "Implement Debouncer with Event Batching and De-duplication",
            "description": "Create a debouncer that batches file change events within a 100ms window, de-duplicates multiple events for the same file, and emits batched results.",
            "dependencies": [
              1
            ],
            "details": "Create internal/watcher/debouncer.go:\n1. Define Debouncer struct with: pending map[string]time.Time, timer *time.Timer, Output chan []string, mutex sync.Mutex\n2. Implement NewDebouncer(window time.Duration) *Debouncer\n3. Implement Add(path string) that:\n   - Locks mutex, adds path to pending map (overwrites if exists for de-dup)\n   - Resets or starts timer for window duration\n4. When timer fires:\n   - Lock mutex, collect all pending paths\n   - Clear pending map, unlock mutex\n   - Send collected paths to Output channel\n5. Implement Stop() for graceful shutdown that stops timer and closes channel\n6. Use time.AfterFunc or time.Timer for the debounce window\n7. Ensure thread-safety for concurrent Add calls from fsnotify",
            "status": "pending",
            "testStrategy": "Test single event emits after window. Test multiple events for same file de-duplicate. Test events within window batch together. Test events after window emit separately. Test Stop() properly cleans up. Test concurrent Add calls are thread-safe."
          },
          {
            "id": 4,
            "title": "Implement Dependency Tracking for Cascading Rebuilds",
            "description": "Create dependency tracking system that maps relationships between asset types so changes to palettes cascade to sprites, sprites cascade to maps, and instruments cascade to SFX and tracks.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create internal/watcher/dependencies.go:\n1. Define DependencyTracker struct with maps for each relationship type\n2. Implement RegisterDependency(source, dependent string) to build dependency graph\n3. Implement GetDependents(path string) []string returning all files that depend on given file\n4. Implement expandDependencies(changed []string) []string that:\n   - For each changed palette: find all sprites using it\n   - For each changed sprite: find all maps using it\n   - For each changed instrument: find all SFX and tracks using it\n   - Recursively expand (palette -> sprite -> map)\n5. Parse asset files on startup to build initial dependency graph\n6. Update dependency graph when files are added/removed\n7. Store palette references in sprites, sprite references in maps, instrument references in SFX/tracks\n8. Handle circular dependency detection (shouldn't occur but guard against)",
            "status": "pending",
            "testStrategy": "Test palette change returns dependent sprites. Test sprite change returns dependent maps. Test instrument change returns dependent SFX and tracks. Test cascading works (palette -> sprite -> map). Test file removal updates dependencies. Test new file registration adds dependencies."
          },
          {
            "id": 5,
            "title": "Implement IncrementalBuild Integration and Watch Command",
            "description": "Integrate the watcher with the build system's IncrementalBuild function and implement the `runefact watch` command with logging, graceful shutdown, and proper exit codes.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "1. Add IncrementalBuild(changed []string) (*BuildResult, error) to internal/build/build.go:\n   - Filter changed files by type\n   - Only rebuild affected files and their dependents\n   - Regenerate manifest after each rebuild\n   - Return BuildResult with affected files and any errors\n2. Implement Watcher.Start(onRebuild func([]string) error) error:\n   - Start debouncer, enter main select loop\n   - Handle fsnotify events, debouncer output, and errors\n   - Call onRebuild callback with expanded dependencies\n3. Add watch command to cmd/runefact/watch.go:\n   - Parse flags, load config\n   - Create Watcher with asset directories from config\n   - Print startup message with watched directories\n   - Log each rebuild: timestamp, affected files, success/failure\n   - Handle SIGINT/SIGTERM for graceful shutdown using signal.Notify\n   - Exit with code 0 on clean shutdown, 1 if last build failed\n4. Implement context-based cancellation for clean shutdown",
            "status": "pending",
            "testStrategy": "Test IncrementalBuild only rebuilds changed files. Test manifest regenerates after rebuild. Test watch command starts and logs startup message. Test Ctrl+C triggers graceful shutdown. Test exit code reflects last build status. Test rebuild logging shows affected files. Test integration with full watcher pipeline."
          }
        ]
      },
      {
        "id": 12,
        "title": "Ebitengine Previewer: Core Window and Sprite Mode",
        "description": "Implement the ebitengine-based previewer with sprite preview mode showing grid layout, animation playback, zoom controls, and live reloading on file changes.",
        "details": "1. Create internal/preview/preview.go:\n   - Define Previewer struct implementing ebiten.Game interface\n   - Handle window creation with configured size\n   - Implement Update() for input handling and animation\n   - Implement Draw() for rendering current mode\n   - Implement Layout() returning window dimensions\n2. Implement sprite preview mode:\n   - Load and display all sprites from a .sprite file\n   - Grid layout: sprites arranged in rows\n   - Animation playback: advance frames based on FPS\n   - Display overlay: sprite name, dimensions, frame count, FPS\n3. Controls (sprite mode):\n   - Mouse wheel: zoom 1x to 32x, nearest-neighbor scaling\n   - Click sprite: isolate view (single sprite centered)\n   - Space: pause/resume animations\n   - Left/Right arrows: step frames when paused\n   - G: toggle pixel grid overlay\n   - B: cycle background (dark, light, checkerboard)\n4. File watching integration:\n   - On file change, reload and re-render\n   - Display error overlay on build failure (red box with message)\n   - Keep showing last good render while error displayed\n5. State persistence:\n   - Save to ~/.config/runefact/preview.json\n   - Remember: window position/size, zoom, background, last file\n   - Load on startup, apply saved state\n6. Command integration:\n   - `runefact preview player.sprite` opens sprite mode\n   - Auto-detect mode from file extension\n\nPseudo-code:\n```go\ntype Previewer struct {\n    mode        PreviewMode\n    sprites     []*RenderedSprite\n    zoom        int\n    background  BackgroundType\n    paused      bool\n    frameTime   float64\n    errorMsg    string\n    lastGood    *ebiten.Image\n}\n\nfunc (p *Previewer) Update() error {\n    // Handle input\n    _, dy := ebiten.Wheel()\n    if dy > 0 {\n        p.zoom = min(32, p.zoom*2)\n    } else if dy < 0 {\n        p.zoom = max(1, p.zoom/2)\n    }\n    \n    if inpututil.IsKeyJustPressed(ebiten.KeySpace) {\n        p.paused = !p.paused\n    }\n    \n    // Advance animations\n    if !p.paused {\n        p.frameTime += 1.0 / 60.0\n        for _, s := range p.sprites {\n            if s.FPS > 0 {\n                s.Frame = int(p.frameTime*float64(s.FPS)) % s.FrameCount\n            }\n        }\n    }\n    \n    return nil\n}\n```",
        "testStrategy": "1. Test window opens with configured dimensions\n2. Test sprites render in grid layout\n3. Test animations play at correct FPS\n4. Test zoom works with nearest-neighbor (no blur)\n5. Test sprite isolation on click\n6. Test pause/resume with Space\n7. Test frame stepping with arrows when paused\n8. Test grid overlay toggle\n9. Test background cycling\n10. Test error overlay appears on build failure\n11. Test state persistence saves and loads correctly\n12. Manual test: edit sprite file, verify live update",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Previewer struct with ebiten.Game interface",
            "description": "Create the core Previewer struct in internal/preview/preview.go that implements ebiten.Game interface with Update(), Draw(), and Layout() methods. Set up window creation with configurable dimensions.",
            "dependencies": [],
            "details": "Define Previewer struct with fields: mode (PreviewMode), sprites ([]*RenderedSprite), zoom (int, default 1), background (BackgroundType), paused (bool), frameTime (float64), errorMsg (string), lastGood (*ebiten.Image), selectedSprite (int for isolation), showGrid (bool). Implement Layout() returning configured window dimensions. Create NewPreviewer() constructor that initializes default state. Set up ebiten.RunGame() integration with window title 'Runefact Preview'. Implement basic Draw() skeleton that clears screen with background color and calls mode-specific render. Implement basic Update() skeleton returning nil.",
            "status": "pending",
            "testStrategy": "Test window opens with configured dimensions (e.g., 800x600). Test Layout() returns correct width/height. Test NewPreviewer() initializes all fields with sensible defaults. Verify ebiten.Game interface is fully implemented."
          },
          {
            "id": 2,
            "title": "Implement sprite loading and grid layout rendering",
            "description": "Load sprites from .sprite files and render them in a grid layout. Each sprite displays its frames arranged horizontally, with multiple sprites stacked vertically.",
            "dependencies": [
              1
            ],
            "details": "Create LoadSprites(path string) function that uses existing sprite parser (Task 3) and renderer (Task 4) to load RenderedSprite data. Define RenderedSprite struct containing: Name, Frames ([]*ebiten.Image), FrameWidth/Height, FPS, CurrentFrame. Implement grid layout calculation: determine cell size based on largest sprite, calculate columns based on window width, arrange sprites in rows. In Draw(), iterate sprites and render current frame at calculated grid positions. Apply zoom using ebiten.GeoM.Scale() with nearest-neighbor (set FilterNearest on DrawImageOptions). Render sprite info overlay showing name, dimensions, frame count, FPS below each sprite.",
            "status": "pending",
            "testStrategy": "Test sprites load from valid .sprite file. Test grid layout arranges sprites correctly with multiple rows when needed. Test zoom scaling applies FilterNearest (no blurring). Test info overlay displays correct metadata for each sprite."
          },
          {
            "id": 3,
            "title": "Implement animation playback system",
            "description": "Add animation playback that advances sprite frames based on their configured FPS values, with pause/resume and frame stepping controls.",
            "dependencies": [
              2
            ],
            "details": "In Update(), track elapsed time using frameTime accumulator (add 1.0/60.0 per tick assuming 60 TPS). For each sprite with FPS > 0, calculate current frame: Frame = int(frameTime * FPS) % FrameCount. When paused, freeze frameTime accumulation. Implement frame stepping: Left arrow decrements frame (wrap to last), Right arrow increments frame (wrap to first). Space key toggles paused state using inpututil.IsKeyJustPressed(). Show pause indicator overlay when paused (e.g., 'PAUSED' text or pause icon). Ensure frame calculations handle single-frame sprites (static, FPS=0) gracefully.",
            "status": "pending",
            "testStrategy": "Test animations play at correct FPS (e.g., 8 FPS sprite shows 8 frames per second). Test Space pauses and resumes animation. Test Left/Right arrows step frames when paused. Test static sprites (FPS=0) don't animate. Test frame wrapping at boundaries."
          },
          {
            "id": 4,
            "title": "Implement input handling for zoom, isolation, grid, and background",
            "description": "Add mouse wheel zoom, click-to-isolate sprite, grid toggle, and background cycling controls.",
            "dependencies": [
              3
            ],
            "details": "Mouse wheel zoom: Use ebiten.Wheel() to get scroll delta. Zoom in on positive dy (double zoom: zoom*2), zoom out on negative dy (halve zoom: zoom/2). Clamp zoom between 1 and 32. Apply nearest-neighbor scaling via ebiten.FilterNearest. Click isolation: Detect mouse click with ebiten.IsMouseButtonJustPressed(). Calculate which sprite was clicked based on grid position and zoom. Set selectedSprite index to isolate (center single sprite in window). Click again or Escape to return to grid view. G key: Toggle showGrid bool. When true, draw 1px lines at pixel boundaries (scaled by zoom) using vector or image drawing. B key: Cycle background through dark (#1a1a1a), light (#e0e0e0), checkerboard (alternating 8x8 pattern). Store as BackgroundType enum.",
            "status": "pending",
            "testStrategy": "Test mouse wheel increases/decreases zoom correctly. Test zoom clamps at 1 and 32. Test click on sprite isolates it centered. Test click/Escape returns to grid view. Test G toggles pixel grid overlay. Test B cycles through all three background types."
          },
          {
            "id": 5,
            "title": "Implement file watching with error overlay display",
            "description": "Integrate file watching to reload sprites on file changes, displaying error overlay on build/parse failures while keeping last good render visible.",
            "dependencies": [
              4
            ],
            "details": "Integrate with file watcher (from Task 11 or fsnotify). Watch the loaded .sprite file and its referenced .palette file. On file change event, attempt to reload sprites. On success: clear errorMsg, update sprites slice, reset animation state. On failure: set errorMsg with error details, keep lastGood image (snapshot of last successful render). In Draw(): if errorMsg is set, render lastGood first, then overlay semi-transparent red box with error message text. Use ebitenutil.DebugPrintAt or custom text rendering for error display. Include file path and line number in error message when available. Debounce rapid file changes (e.g., 100ms delay before reload).",
            "status": "pending",
            "testStrategy": "Test file modification triggers reload. Test successful reload updates displayed sprites. Test parse error shows red overlay with message. Test last good render remains visible during error. Test error clears when file is fixed. Test rapid saves don't cause multiple reloads."
          },
          {
            "id": 6,
            "title": "Implement state persistence and command integration",
            "description": "Save and restore previewer state (window position, zoom, background, last file) to ~/.config/runefact/preview.json, and integrate with CLI command.",
            "dependencies": [
              5
            ],
            "details": "Define PreviewState struct: WindowX, WindowY, WindowWidth, WindowHeight (int), Zoom (int), Background (string), LastFile (string), ShowGrid (bool). Create state file path: ~/.config/runefact/preview.json (use os.UserConfigDir()). On startup: load state if exists, apply saved values (window position via ebiten.SetWindowPosition, zoom, background, etc.). If lastFile exists and no file argument provided, open it. On state change or window close: save current state to JSON file. Create parent directory if needed. Integrate with CLI: Add 'preview' command that accepts file path argument. Auto-detect mode from extension (.sprite -> sprite mode). Example: 'runefact preview player.sprite'. Pass file path to NewPreviewer() and start ebiten.RunGame().",
            "status": "pending",
            "testStrategy": "Test state file created in correct location. Test window position/size restored on restart. Test zoom and background settings persist. Test last file reopens when no argument provided. Test CLI 'runefact preview player.sprite' opens sprite mode. Test state saves on window close."
          }
        ]
      },
      {
        "id": 13,
        "title": "Previewer: Map and Audio Modes",
        "description": "Extend the previewer with map preview mode (tile rendering, layer visibility, entity markers) and audio preview modes (SFX waveform display, music tracker view, transport controls).",
        "details": "1. Map preview mode:\n   - Render composited tile layers in correct order\n   - Pan with WASD/arrow keys\n   - Zoom with mouse wheel\n   - Tab: cycle layer visibility (all, individual, entity overlay)\n   - G: toggle tile grid overlay\n   - Entity markers: colored shapes with type labels\n   - Handle large maps with viewport culling\n2. SFX preview mode:\n   - Display waveform visualization (pre-rendered from WAV)\n   - Show envelope shape graph\n   - Show pitch curve graph (if pitch sweep)\n   - Show filter sweep graph (if filter sweep)\n   - Enter: play sound once\n   - Volume: +/- keys, mouse drag on knob\n   - Peak meter during playback\n3. Music preview mode:\n   - Tracker-style pattern view: scrolling rows, channel columns\n   - Current row highlighted\n   - Song position display: pattern name, row, elapsed time\n   - Enter: start playback from beginning\n   - Space: pause/resume\n   - Escape: stop and reset\n   - Left/Right: skip to previous/next pattern\n   - Volume controls\n4. Audio safety in previewer:\n   - NEVER auto-play on load or file change\n   - Stop playback on file change\n   - Brickwall limiter on all output\n   - Peak meter always visible during playback\n   - DC offset removal (10Hz high-pass)\n   - Clipping warning if sustained max amplitude\n5. Asset browser mode:\n   - `runefact preview` with no argument\n   - Tree view of all rune files\n   - Click to preview any file\n   - File watcher on entire project\n\nPseudo-code for audio player:\n```go\ntype AudioPlayer struct {\n    context   *audio.Context\n    player    *audio.Player\n    limiter   *Limiter\n    peakMeter float64\n    playing   bool\n}\n\nfunc (a *AudioPlayer) Play(samples []float64) {\n    // Apply limiter\n    limited := a.limiter.Process(samples)\n    \n    // Convert to bytes\n    buf := samplesToBytes(limited)\n    \n    a.player = audio.NewPlayerFromBytes(a.context, buf)\n    a.playing = true\n    \n    go func() {\n        for a.playing {\n            a.peakMeter = calculatePeak(a.player.Current())\n        }\n    }()\n    \n    a.player.Play()\n}\n```",
        "testStrategy": "1. Test map renders all tile layers in order\n2. Test map panning and zooming\n3. Test layer visibility cycling\n4. Test entity markers display correctly\n5. Test large map viewport culling\n6. Test SFX waveform displays correctly\n7. Test SFX plays on Enter, not on load\n8. Test music tracker view scrolls with playback\n9. Test music transport controls (play/pause/stop)\n10. Test pattern navigation (prev/next)\n11. Test audio stops on file change\n12. Test peak meter updates during playback\n13. Test clipping warning appears for broken audio\n14. Test asset browser lists all files\n15. Test clicking file in browser switches preview",
        "priority": "medium",
        "dependencies": [
          12
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Map Preview Mode: Layer Compositing with Panning and Zooming",
            "description": "Implement the map preview renderer that composites tile layers in correct z-order, with viewport-based culling for large maps, and adds WASD/arrow key panning plus mouse wheel zoom controls.",
            "dependencies": [],
            "details": "Create internal/preview/map_preview.go with MapPreviewer struct. Implement layer compositing that renders tile layers bottom-to-top using the tileset sprites. Add viewport tracking (camera position and zoom level). Implement panning: WASD and arrow keys move camera by tile increments, with smooth interpolation optional. Implement zooming: mouse wheel adjusts zoom factor (0.25x to 4x typical range), maintaining cursor-centered zoom. For large maps, implement viewport culling: only render tiles within visible screen bounds plus 1-tile margin. Use ebiten.GeoM for zoom and pan transforms. Store camera state (x, y float64, zoom float64). Calculate visible tile range from viewport bounds divided by tile size times zoom.",
            "status": "pending",
            "testStrategy": "Test tile layers render in correct z-order. Test panning moves viewport correctly with WASD and arrow keys. Test zoom with mouse wheel centers on cursor position. Test viewport culling by verifying only visible tiles are drawn (add draw counter). Test zoom bounds are enforced. Test large map (1000x1000) renders without lag due to culling."
          },
          {
            "id": 2,
            "title": "Map Preview Mode: Layer Visibility Cycling and Entity Markers",
            "description": "Add layer visibility controls (Tab to cycle through all/individual/entity-only views), G key for grid overlay toggle, and entity marker rendering with colored shapes and type labels.",
            "dependencies": [
              1
            ],
            "details": "Extend MapPreviewer with visibility state: enum for All, Layer1, Layer2, ..., EntityOnly modes. Tab cycles through modes. Track current layer index. When in individual layer mode, only draw that layer. Implement grid overlay: G toggles gridVisible bool, draw 1px lines at tile boundaries using vector drawing or pre-rendered grid texture. For entity markers: parse entity data from map file (position, type, properties). Define color scheme per entity type (spawn=green, trigger=yellow, enemy=red, etc.). Draw colored shapes (rectangles or circles) at entity world positions. Render type label text using ebitenutil.DebugPrint or small font. Entity overlay renders on top of all tile layers. Show current mode in UI corner (e.g., 'Layer: All' or 'Layer: 2/4').",
            "status": "pending",
            "testStrategy": "Test Tab cycles through visibility modes correctly. Test individual layer mode hides other layers. Test entity-only mode shows markers without tiles. Test G toggles grid overlay on/off. Test entity markers appear at correct positions with correct colors. Test entity type labels are readable. Test mode indicator displays current state."
          },
          {
            "id": 3,
            "title": "SFX Preview Mode: Waveform and Envelope/Pitch Graph Display",
            "description": "Implement SFX preview mode with waveform visualization rendered from WAV data, plus envelope shape graph, pitch curve graph (when pitch sweep exists), and filter sweep graph (when filter sweep exists).",
            "dependencies": [],
            "details": "Create internal/preview/sfx_preview.go with SFXPreviewer struct. Pre-render waveform: load WAV samples, downsample to screen width (e.g., 800 points), store min/max pairs per column for visualization. Draw waveform as vertical lines from min to max amplitude, centered on zero line. For envelope graph: parse ADSR or envelope points from .sfx file, draw as line graph (time on x-axis, amplitude on y-axis). For pitch curve: if pitchSweep field exists, draw pitch over time as line graph. For filter sweep: if filterSweep exists, draw cutoff frequency over time. Use distinct colors: waveform=cyan, envelope=green, pitch=orange, filter=magenta. Layout: waveform takes 60% height, graphs share remaining 40% in horizontal panels. Add axis labels and value indicators. Store graphs as pre-rendered ebiten.Image for performance.",
            "status": "pending",
            "testStrategy": "Test waveform renders with correct amplitude visualization. Test envelope graph displays ADSR shape accurately. Test pitch curve only shows when pitch sweep exists in file. Test filter graph only shows when filter sweep exists. Test graphs update when different SFX file loaded. Test graph colors are distinguishable. Test waveform handles mono and stereo files."
          },
          {
            "id": 4,
            "title": "Music Preview Mode: Tracker-Style Pattern View with Scrolling",
            "description": "Implement music preview mode with tracker-style pattern display showing scrolling rows, channel columns, highlighted current row, and song position display (pattern name, row number, elapsed time).",
            "dependencies": [],
            "details": "Create internal/preview/music_preview.go with MusicPreviewer struct. Parse .track file to extract patterns and channel data. Create tracker grid renderer: fixed-width columns per channel, rows for pattern steps. Use monospace font for note display (e.g., 'C-4', 'D#5', '---' for empty). Implement vertical scrolling: current playback row stays centered, rows scroll past. Highlight current row with distinct background color. Display channel headers (CH1, CH2, etc.). Show song position panel: current pattern name, row number (e.g., '08/32'), elapsed time (MM:SS.ms format). Calculate elapsed time from tempo and rows played. Support pattern view scrolling independent of playback (arrow keys when paused). Color-code notes by octave or channel. Handle variable pattern lengths.",
            "status": "pending",
            "testStrategy": "Test pattern rows display in correct order. Test channel columns show correct note data. Test current row highlighting moves during playback. Test scrolling keeps current row visible. Test song position shows correct pattern name. Test row counter increments correctly. Test elapsed time calculates accurately from tempo. Test arrow keys scroll view when paused."
          },
          {
            "id": 5,
            "title": "Audio Playback Integration with Transport Controls",
            "description": "Integrate ebitengine/audio for playback with transport controls: Enter to play/start, Space to pause/resume, Escape to stop/reset, Left/Right for pattern skip in music mode, and +/- for volume control with visual knob.",
            "dependencies": [
              3,
              4
            ],
            "details": "Create internal/preview/audio_player.go with AudioPlayer struct wrapping ebitengine/audio. Initialize audio.Context at 44100Hz. For SFX: load WAV bytes, create Player, implement single-shot playback on Enter. For music: implement streaming playback from pattern data. Transport controls - SFX: Enter plays once from start. Music: Enter starts from beginning, Space toggles pause/resume, Escape stops and resets to start, Left/Right skip to previous/next pattern (with bounds checking). Volume control: +/- keys adjust volume (0.0-1.0 range, 0.1 steps), store in AudioPlayer. Draw volume knob/slider UI element, support mouse drag on knob. Display current volume percentage. Remember volume across file changes. Implement proper cleanup: stop playback before loading new file, release Player resources.",
            "status": "pending",
            "testStrategy": "Test Enter plays SFX exactly once. Test Enter starts music from beginning. Test Space pauses and resumes music playback. Test Escape stops music and resets position. Test Left/Right navigate patterns correctly. Test volume +/- adjusts in correct increments. Test volume knob responds to mouse drag. Test playback stops when loading new file. Test no audio artifacts on stop/start."
          },
          {
            "id": 6,
            "title": "Audio Safety: No Auto-Play, Limiter, Peak Meter, Clipping Warning",
            "description": "Implement audio safety features: prevent auto-play on load or file change, apply brickwall limiter to output, show always-visible peak meter during playback, add DC offset removal (10Hz high-pass), and display clipping warning on sustained max amplitude.",
            "dependencies": [
              5
            ],
            "details": "Extend AudioPlayer with safety processing chain. NEVER auto-play rule: set playing=false on construction and file change, require explicit user action (Enter key). Implement Stop() on file change events. Brickwall limiter: create Limiter struct with threshold (e.g., -0.5dB = 0.944), apply tanh soft clipping or hard clip at threshold. DC offset removal: implement simple 10Hz high-pass filter using single-pole IIR (y[n] = x[n] - x[n-1] + 0.995 * y[n-1]). Peak meter: track maximum absolute sample value over sliding window (100ms), decay slowly when below peak. Draw peak meter as vertical bar, always visible during playback mode. Color zones: green (0-70%), yellow (70-90%), red (90-100%). Clipping detection: if peak stays at max (>0.99) for more than 500ms, show 'CLIPPING' warning in red. Reset warning on level drop.",
            "status": "pending",
            "testStrategy": "Test audio never plays automatically on file load. Test audio stops when switching files. Test limiter prevents output exceeding threshold. Test DC offset filter removes low-frequency bias. Test peak meter displays and decays correctly. Test peak meter color zones transition properly. Test clipping warning appears on sustained max amplitude. Test clipping warning clears when levels drop."
          },
          {
            "id": 7,
            "title": "Asset Browser Mode: Tree View and Project-Wide File Watching",
            "description": "Implement asset browser mode activated with `runefact preview` (no arguments), showing a tree view of all rune files, click-to-preview functionality, and file watcher on the entire project for live updates.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6
            ],
            "details": "Create internal/preview/browser.go with AssetBrowser struct. When `runefact preview` called without file argument, enter browser mode instead of single-file preview. Scan project directory recursively for all .palette, .sprite, .map, .inst, .sfx, .track files. Build tree structure matching directory hierarchy. Render tree view: collapsible folders with +/- toggles, file entries with type-specific icons or color coding. Implement click handling: click on file loads and previews it in right panel (60/40 split layout). Track selected file with highlight. Implement file watcher using fsnotify on entire project root. On file changes: if new file, add to tree; if deleted, remove from tree; if modified and currently previewed, trigger reload. Sort files alphabetically within folders. Show file count summary. Support keyboard navigation: arrow keys move selection, Enter previews selected file, Backspace goes to parent folder.",
            "status": "pending",
            "testStrategy": "Test browser mode activates when no file argument given. Test tree view shows all supported file types. Test folders are collapsible. Test click on file loads preview. Test file watcher detects new files and adds to tree. Test file watcher detects deletions and removes from tree. Test modified file triggers preview reload if selected. Test keyboard navigation works. Test tree sorts alphabetically."
          }
        ]
      },
      {
        "id": 14,
        "title": "MCP Server Implementation",
        "description": "Implement the MCP (Model Context Protocol) server exposing Runefact operations as tools and resources for AI agents, with stdio transport for Claude Code and Claude Desktop integration.",
        "details": "1. Create internal/mcp/server.go:\n   - Initialize MCP server using github.com/mark3labs/mcp-go\n   - Configure stdio transport\n   - Register all tools and resources\n   - Handle tool calls and resource reads\n2. Implement tools in internal/mcp/tools.go:\n   - runefact_build: compile assets with scope/files options\n   - runefact_validate: check files without building\n   - runefact_inspect_sprite: get sprite sheet metadata\n   - runefact_inspect_map: get map metadata\n   - runefact_inspect_audio: get audio metadata\n   - runefact_list_assets: list all rune files by type\n   - runefact_palette_colors: get resolved palette colors\n   - runefact_scaffold: create skeleton rune files\n   - runefact_format_help: get format documentation\n3. Implement resources in internal/mcp/resources.go:\n   - runefact://project/status: project state, build status\n   - runefact://formats/{type}: format specification\n   - runefact://palette/{name}: resolved palette colors\n   - runefact://manifest: current manifest data as JSON\n4. Tool input/output schemas:\n   - Define JSON schemas for all tool inputs\n   - Return structured JSON (not prose) for all outputs\n   - Include errors array with file/line/message\n5. Error handling:\n   - No runefact.toml: clear error with fix instructions\n   - Build in progress: serialize with mutex, wait up to 30s\n   - Invalid input: JSON schema validation error\n6. `runefact mcp` command:\n   - Start server on stdio\n   - Find project root from cwd\n   - Log to stderr (not stdout, which is MCP protocol)\n\nPseudo-code:\n```go\nfunc StartMCPServer(projectRoot string) error {\n    cfg, err := config.Load(projectRoot)\n    if err != nil {\n        return fmt.Errorf(\"no_project: %w\", err)\n    }\n    \n    server := mcp.NewServer()\n    ctx := &ServerContext{Config: cfg, Root: projectRoot}\n    \n    // Register tools\n    server.RegisterTool(\"runefact_build\", ctx.handleBuild)\n    server.RegisterTool(\"runefact_validate\", ctx.handleValidate)\n    server.RegisterTool(\"runefact_inspect_sprite\", ctx.handleInspectSprite)\n    // ... more tools\n    \n    // Register resources\n    server.RegisterResource(\"runefact://project/status\", ctx.getProjectStatus)\n    server.RegisterResource(\"runefact://formats/*\", ctx.getFormatSpec)\n    // ... more resources\n    \n    return server.ServeStdio()\n}\n```",
        "testStrategy": "1. Test MCP server starts on stdio\n2. Test each tool with valid inputs returns expected JSON\n3. Test runefact_build produces artifacts and returns metadata\n4. Test runefact_validate returns errors for invalid files\n5. Test runefact_scaffold creates valid file content\n6. Test runefact_format_help returns documentation\n7. Test resources return correct data\n8. Test error responses have correct structure\n9. Test invalid tool input returns schema error\n10. Test concurrent build calls are serialized\n11. Integration test with MCP client library",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "MCP Server Core Setup with mcp-go and Stdio Transport",
            "description": "Create internal/mcp/server.go implementing the core MCP server using github.com/mark3labs/mcp-go library with stdio transport for Claude Code/Desktop integration.",
            "dependencies": [],
            "details": "Initialize the MCP server package structure with:\n1. Create internal/mcp/server.go with ServerContext struct holding Config, ProjectRoot, and build mutex\n2. Implement StartMCPServer(projectRoot string) entry point that finds runefact.toml and initializes context\n3. Configure stdio transport - all protocol output to stdout, logging to stderr only\n4. Implement proper error handling for no-project case returning structured JSON: {\"error\": \"no_project\", \"message\": \"No runefact.toml found...\"}\n5. Add build serialization mutex with 30-second timeout for concurrent tool call handling\n6. Implement graceful shutdown handling for client disconnection\n7. Create the `runefact mcp` CLI command in cmd/ that calls StartMCPServer with cwd-based project root detection\n8. Register placeholder tool and resource handlers (to be implemented in subsequent subtasks)",
            "status": "pending",
            "testStrategy": "Test MCP server starts on stdio with valid project. Test no-project error returns correct JSON structure. Test logging goes to stderr not stdout. Test mutex serializes concurrent requests. Test shutdown is graceful. Integration test: start server subprocess, verify it responds to MCP protocol messages."
          },
          {
            "id": 2,
            "title": "Implement MCP Tool Handlers for Build, Validate, and Inspect Operations",
            "description": "Create internal/mcp/tools.go implementing all 9 MCP tools: runefact_build, runefact_validate, runefact_inspect_sprite, runefact_inspect_map, runefact_inspect_audio, runefact_list_assets, runefact_palette_colors, runefact_scaffold, runefact_format_help.",
            "dependencies": [
              1
            ],
            "details": "Implement each tool handler wrapping existing internal packages:\n1. runefact_build: call build.Execute() with scope (all/sprites/maps/audio) and optional files filter, return {success, artifacts[], errors[], warnings[], manifest_path}\n2. runefact_validate: call build.Validate() returning {valid, errors[], warnings[]} without writing output files\n3. runefact_inspect_sprite: parse sprite file and return {file, output_path, sprites: [{name, width, height, frames, framerate, x, y}], palette}\n4. runefact_inspect_map: return {file, output_path, tile_size, width, height, layers, tileset_sprites, entity_types}\n5. runefact_inspect_audio: return {file, output_path, type, duration_ms, sample_rate, channels} with type-specific fields (pitch envelope for sfx, bpm/tracks for music)\n6. runefact_list_assets: enumerate rune files with optional type filter, return {assets: [{file, type, last_modified}], last_build}\n7. runefact_palette_colors: resolve palette for a file returning {palette, colors: {key: hex_color}}\n8. runefact_scaffold: generate skeleton files with options (grid size, frame count, animated, width, height), handle overwrite flag\n9. runefact_format_help: return format documentation with sections array\nAll tools return structured JSON, errors as arrays with file/line/message, never prose.",
            "status": "pending",
            "testStrategy": "Test runefact_build with scope filters produces correct artifacts. Test runefact_validate catches errors without writing files. Test inspect tools return correct metadata for demo assets. Test runefact_list_assets returns all file types. Test runefact_palette_colors resolves multi-char bracket keys. Test runefact_scaffold creates valid buildable files. Test runefact_format_help returns non-empty documentation. Test all error responses include structured file/line/message arrays."
          },
          {
            "id": 3,
            "title": "Implement MCP Resource Handlers for Project State and Format Specs",
            "description": "Create internal/mcp/resources.go implementing the 4 MCP resources: runefact://project/status, runefact://formats/{type}, runefact://palette/{name}, runefact://manifest.",
            "dependencies": [
              1
            ],
            "details": "Implement read-only resource handlers:\n1. runefact://project/status: return {project_name, root, runefact_version, valid, last_build, errors[]} aggregating current project state from config and build cache\n2. runefact://formats/{type}: return complete Markdown documentation for palette/sprite/map/instrument/sfx/track formats, same content as format_help tool but as subscribable resource. Use wildcard pattern matching for {type} parameter\n3. runefact://palette/{name}: return resolved color map {name, colors: {key: hex}} for named palette file, including all single-char and bracket [xx] multi-char keys\n4. runefact://manifest: return current manifest data as JSON {sprites: {}, maps: {}, audio: {}} matching manifest.go structure but machine-readable, or null/error if never built\n5. Ensure all resources are read-only with no side effects\n6. Resource handlers should work even when project hasn't been built yet (return appropriate state)\n7. Cache resource content where appropriate for performance",
            "status": "pending",
            "testStrategy": "Test project/status returns valid JSON with all fields. Test formats/{type} returns Markdown for each valid type (palette, sprite, map, instrument, sfx, track). Test invalid format type returns error. Test palette/{name} resolves correct colors including multi-char keys. Test manifest returns null when never built, correct JSON after build. Test resources never modify files."
          },
          {
            "id": 4,
            "title": "Define JSON Schemas for Tool Inputs and Structured Output Formats",
            "description": "Create internal/mcp/schemas.go defining JSON schema specifications for all tool inputs and outputs, ensuring type-safe structured communication with MCP clients.",
            "dependencies": [
              1
            ],
            "details": "Define comprehensive JSON schemas:\n1. Create input schemas for each tool:\n   - BuildInput: {scope?: enum, files?: string[]}\n   - ValidateInput: {files?: string[]}\n   - InspectSpriteInput: {file: string}\n   - InspectMapInput: {file: string}\n   - InspectAudioInput: {file: string}\n   - ListAssetsInput: {type?: enum}\n   - PaletteColorsInput: {file: string}\n   - ScaffoldInput: {type: enum, name: string, options?: {grid?: int, animated?: bool, frame_count?: int, width?: int, height?: int, palette?: string}, overwrite?: bool}\n   - FormatHelpInput: {type: enum}\n2. Define output schemas for each tool with required and optional fields\n3. Define error schema: {error: string, message: string, file?: string, line?: int, column?: int}\n4. Define BuildError array schema: [{file, line, column, message, severity}]\n5. Register schemas with mcp-go server for automatic validation\n6. Return JSON schema validation errors with specific field that failed when input is invalid\n7. Export schema definitions for documentation generation",
            "status": "pending",
            "testStrategy": "Test schema validation rejects missing required fields. Test schema validation rejects wrong types. Test enum validation rejects invalid values. Test optional fields work when omitted. Test error responses match error schema. Test all tool outputs conform to defined output schemas. Generate schema docs and verify they match PRD specifications."
          },
          {
            "id": 5,
            "title": "Integration Testing and Error Handling for MCP Server",
            "description": "Create comprehensive integration tests and robust error handling covering all MCP edge cases including no-project detection, concurrent build serialization, and invalid input handling.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Implement end-to-end testing and error handling:\n1. Create internal/mcp/server_test.go with integration tests:\n   - Test full MCP protocol flow: connect, list tools, call tool, read resource, disconnect\n   - Test each tool with valid inputs returns expected JSON structure\n   - Test each resource URI returns correct content\n2. Error handling scenarios:\n   - No runefact.toml: all tools return {\"error\": \"no_project\", \"message\": \"No runefact.toml found. Run 'runefact init' to create a project.\"}\n   - Not built yet: inspect tools return {\"error\": \"not_built\", \"message\": \"No build artifacts found. Call runefact_build first.\"}\n   - Build in progress: mutex serialization with 30s timeout, return timeout error if exceeded\n   - File not found: return specific file path in error\n   - Invalid JSON schema input: return validation error with field name\n   - Scaffold existing file without overwrite: return {\"error\": \"file_exists\", \"message\": \"...\"}\n3. Test concurrent tool calls are properly serialized\n4. Test MCP client disconnection mid-build completes cleanly\n5. Performance test: runefact_list_assets is fast even with hundreds of files\n6. Create test fixtures with demo project for all test scenarios",
            "status": "pending",
            "testStrategy": "Run full integration test suite against demo project. Test no-project error by running outside any project. Test concurrent builds with parallel tool calls. Test timeout behavior with artificially slow build. Test all error scenarios return correct structured JSON. Profile runefact_list_assets with large file set. Test graceful handling of malformed MCP messages."
          }
        ]
      },
      {
        "id": 15,
        "title": "VS Code Extension: Syntax Highlighting",
        "description": "Create the VS Code extension with TextMate grammars for all Runefact file formats, providing syntax highlighting with TOML base, pixel grid coloring, and tracker pattern coloring.",
        "details": "1. Create vscode/runefact-vscode/ extension structure:\n   - package.json: extension manifest with language contributions\n   - syntaxes/: TextMate grammar JSON files\n   - src/extension.ts: extension entry point\n2. File associations in package.json:\n   - .palette -> runefact-palette\n   - .sprite -> runefact-sprite\n   - .map -> runefact-map\n   - .inst -> runefact-instrument\n   - .sfx -> runefact-sfx\n   - .track -> runefact-track\n   - File icons for each type\n3. TextMate grammars (inject on top of TOML):\n   - Base TOML highlighting for keys, values, sections\n   - Palette: hex color values highlighted\n   - Sprite: pixels=\"\"\"...\"\"\" blocks with grid parsing\n   - Map: layer pixels blocks with tileset char coloring\n   - Track: pattern data blocks with note coloring\n4. Pixel grid coloring:\n   - Parse palette to get color mappings\n   - Apply background color decoration to each grid character\n   - Handle bracket [xx] multi-char keys\n   - _ (transparent) gets checkerboard/dotted background\n5. Tracker note coloring:\n   - Chromatic pitch-class colors: C=red, D=orange, E=yellow, etc.\n   - --- (sustain) dimmed gray\n   - ... (silence) very dim\n   - ^^^ (note-off) distinct style (italic or different color)\n   - Effect suffixes (v08, >02) as modifiers\n6. Color decorators:\n   - Use DocumentColorProvider for hex colors\n   - Show color swatch next to hex values\n   - Color picker on click\n\nPackage.json structure:\n```json\n{\n  \"name\": \"runefact\",\n  \"displayName\": \"Runefact\",\n  \"contributes\": {\n    \"languages\": [\n      { \"id\": \"runefact-sprite\", \"extensions\": [\".sprite\"], \"aliases\": [\"Runefact Sprite\"] }\n    ],\n    \"grammars\": [\n      { \"language\": \"runefact-sprite\", \"scopeName\": \"source.runefact.sprite\", \"path\": \"./syntaxes/runefact-sprite.tmLanguage.json\" }\n    ]\n  }\n}\n```",
        "testStrategy": "1. Test file associations register correctly\n2. Test TOML base highlighting works\n3. Test hex colors show inline color swatches\n4. Test pixel grid characters get background colors\n5. Test bracket [xx] keys colored correctly\n6. Test transparent _ has distinct styling\n7. Test tracker notes have chromatic colors\n8. Test ---, ..., ^^^ have distinct styles\n9. Test extension loads without errors\n10. Test in VS Code, Cursor, and Windsurf\n11. Visual regression tests with screenshots",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "VS Code Extension Project Setup",
            "description": "Create the VS Code extension project structure with package.json manifest, TypeScript configuration, and all language/file type registrations.",
            "dependencies": [],
            "details": "Create vscode/runefact-vscode/ directory with:\n\n1. package.json with extension manifest:\n   - name: 'runefact', displayName: 'Runefact'\n   - engines.vscode: '^1.85.0'\n   - activationEvents: onLanguage for all Runefact types\n   - contributes.languages: register all 6 file types (.palette, .sprite, .map, .inst, .sfx, .track) with IDs like runefact-palette, runefact-sprite, etc.\n   - contributes.grammars: map each language to its TextMate grammar file\n   - contributes.icons: file icons for each type\n   - main: './out/extension.js'\n\n2. tsconfig.json:\n   - target: ES2022, module: commonjs\n   - outDir: './out', rootDir: './src'\n   - strict: true, esModuleInterop: true\n\n3. src/extension.ts:\n   - activate() function registering all providers\n   - deactivate() cleanup function\n   - Export both functions\n\n4. Directory structure:\n   - syntaxes/ for TextMate grammar JSON files\n   - src/ for TypeScript source\n   - icons/ for file type icons\n\n5. .vscodeignore and README.md for extension packaging",
            "status": "pending",
            "testStrategy": "Verify extension loads without errors in VS Code Extension Development Host. Confirm all 6 file types are recognized and associated with correct language IDs. Test that files with .palette, .sprite, .map, .inst, .sfx, .track extensions open with Runefact language mode selected. Verify extension activates when opening any Runefact file."
          },
          {
            "id": 2,
            "title": "TextMate Grammars for All File Types",
            "description": "Create TextMate grammar JSON files for each Runefact file format, injecting custom highlighting on top of TOML base syntax.",
            "dependencies": [
              1
            ],
            "details": "Create syntaxes/ directory with TextMate grammars:\n\n1. runefact-base.tmLanguage.json:\n   - Inherit from source.toml patterns\n   - Define common Runefact patterns (section headers, key-value pairs)\n\n2. runefact-palette.tmLanguage.json:\n   - scopeName: source.runefact.palette\n   - Highlight hex color values (#RRGGBB, #RRGGBBAA) with entity.other.color scope\n   - Single character keys as variable.other.constant\n\n3. runefact-sprite.tmLanguage.json:\n   - scopeName: source.runefact.sprite\n   - Match pixels=\"\"\"...\"\"\" multiline blocks with string.unquoted.pixel-grid\n   - Frame dimensions as constant.numeric\n   - Animation timing values\n\n4. runefact-map.tmLanguage.json:\n   - scopeName: source.runefact.map\n   - Layer pixel blocks similar to sprite\n   - Tileset references in brackets\n\n5. runefact-instrument.tmLanguage.json and runefact-sfx.tmLanguage.json:\n   - Waveform types as keyword.other\n   - Envelope values (attack/decay/sustain/release) as constant.numeric\n\n6. runefact-track.tmLanguage.json:\n   - Pattern blocks with note syntax highlighting\n   - Tempo/time signature as constant.numeric\n\nAll grammars use 'include': 'source.toml' for base TOML highlighting and add injectionSelector for Runefact-specific patterns.",
            "status": "pending",
            "testStrategy": "Open each file type in VS Code and verify TOML syntax (sections, keys, strings) highlights correctly. Test that hex colors in .palette files get color scope. Test that pixel grid blocks in .sprite and .map files are recognized as distinct regions. Test that numeric values for timing/tempo are highlighted as constants."
          },
          {
            "id": 3,
            "title": "Pixel Grid Coloring with Palette Parsing",
            "description": "Implement programmatic decoration of pixel grid characters with background colors based on parsed palette definitions, including bracket [xx] multi-char key handling and transparent styling.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create src/pixelGridDecorator.ts:\n\n1. Palette parser:\n   - Read associated .palette file (from [palette] section or default)\n   - Parse key = '#RRGGBB' mappings into Map<string, Color>\n   - Handle single-char keys (A-Z, a-z, 0-9, symbols)\n   - Handle bracket notation [xx] for multi-char keys\n\n2. DecorationProvider implementation:\n   - Register for runefact-sprite and runefact-map languages\n   - Create TextEditorDecorationType for each palette color with backgroundColor\n   - Parse pixel grid regions (between \"\"\" markers)\n   - Match each character/bracket-key to palette color\n   - Apply decoration ranges\n\n3. Special character handling:\n   - _ (transparent): checkerboard pattern via CSS background-image gradient\n   - Unknown keys: error-style decoration (red underline or border)\n   - [xx] bracket keys: treat as single unit, color both brackets and content\n\n4. Event handling:\n   - Update decorations on document change\n   - Update when palette file changes (FileSystemWatcher)\n   - Cache parsed palette per workspace\n\n5. Performance:\n   - Debounce decoration updates (100ms)\n   - Only decorate visible ranges for large files",
            "status": "pending",
            "testStrategy": "Open a .sprite file with associated palette and verify each grid character gets correct background color from palette. Test bracket [xx] keys display as single colored unit. Test _ transparent character shows checkerboard/distinct pattern. Test unknown palette keys show error styling. Test changing palette file updates sprite decorations. Test performance with large sprite files (100+ lines)."
          },
          {
            "id": 4,
            "title": "Tracker Note Coloring with Chromatic Pitch Classes",
            "description": "Implement syntax highlighting and decorations for tracker pattern data with chromatic pitch-class colors, sustain/silence/note-off styling, and effect suffix handling.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create src/trackerDecorator.ts:\n\n1. Chromatic pitch-class color mapping:\n   - C: red (#FF0000), C#/Db: red-orange\n   - D: orange (#FF8000), D#/Eb: orange-yellow\n   - E: yellow (#FFFF00)\n   - F: yellow-green (#80FF00)\n   - G: green (#00FF00), G#/Ab: green-cyan\n   - A: cyan (#00FFFF), A#/Bb: cyan-blue\n   - B: blue (#0080FF)\n   - Define as configuration for customization\n\n2. Note pattern matching:\n   - Full note: pitch + octave (e.g., C-4, F#3, Bb5)\n   - Parse pitch class and apply color to full note text\n   - Octave number in slightly dimmed shade of same hue\n\n3. Special symbol styling:\n   - --- (sustain): dimmed gray (#666666), italic\n   - ... (silence): very dim (#333333), reduced opacity\n   - ^^^ (note-off): distinct color (#AA00AA), italic or different background\n\n4. Effect suffix handling:\n   - Match effect codes: v08 (volume), >02 (slide), etc.\n   - Style as constant.numeric with muted color\n   - Don't interfere with note pitch coloring\n\n5. Pattern block detection:\n   - Identify pattern sections in .track files\n   - Apply decorations only within pattern data regions\n   - Handle column alignment (4 chars per note typically)\n\n6. DecorationProvider:\n   - Register for runefact-track language\n   - Update decorations on document change with debounce",
            "status": "pending",
            "testStrategy": "Open a .track file with pattern data and verify C notes are red, D notes orange, etc. through full chromatic scale. Test sharp/flat notes get correct intermediate colors. Test --- sustain shows as dimmed gray italic. Test ... silence is very dim. Test ^^^ note-off has distinct styling. Test effect suffixes (v08, >02) are styled separately from notes. Test column alignment is preserved visually."
          },
          {
            "id": 5,
            "title": "Color Decorators with DocumentColorProvider",
            "description": "Implement DocumentColorProvider for hex color values showing inline color swatches and enabling color picker interaction for palette files.",
            "dependencies": [
              1
            ],
            "details": "Create src/colorProvider.ts:\n\n1. DocumentColorProvider implementation:\n   - Register for runefact-palette language\n   - Implement provideDocumentColors():\n     - Scan document for hex color patterns (#RGB, #RRGGBB, #RRGGBBAA)\n     - Return ColorInformation[] with Range and Color\n   - Implement provideColorPresentations():\n     - Convert Color back to hex string format\n     - Preserve original format (6-digit vs 8-digit)\n\n2. Hex color pattern matching:\n   - 6-digit: #RRGGBB -> RGB values 0-255\n   - 8-digit: #RRGGBBAA -> RGBA with alpha\n   - Case-insensitive matching (accept #ff0000 and #FF0000)\n\n3. Color representation:\n   - Convert hex to VS Code Color (r, g, b, a as 0-1 floats)\n   - Convert Color back to hex maintaining format consistency\n\n4. Color swatch display:\n   - VS Code automatically shows color swatch for ColorInformation\n   - Clicking swatch opens native color picker\n   - Selected color updates document via provideColorPresentations\n\n5. Registration:\n   - Register provider in extension.ts activate()\n   - Dispose on deactivate()\n\n6. Optional: extend to other file types:\n   - Could show color swatches in .sprite/.map comments if hex colors present",
            "status": "pending",
            "testStrategy": "Open a .palette file and verify color swatches appear next to each hex color value. Test clicking a swatch opens the VS Code color picker. Test selecting a new color updates the hex value in the document. Test both 6-digit (#RRGGBB) and 8-digit (#RRGGBBAA) formats work correctly. Test lowercase and uppercase hex values are both recognized. Test invalid hex patterns don't show swatches."
          }
        ]
      },
      {
        "id": 16,
        "title": "VS Code Extension: Inline Validation and Diagnostics",
        "description": "Add inline validation to the VS Code extension with diagnostics for structural errors, cross-file reference checking, and Problems panel integration.",
        "details": "1. Create src/diagnostics.ts:\n   - Implement DocumentDiagnosticProvider\n   - Register for all Runefact file types\n   - Run validation on save (configurable)\n2. Validation rules by file type:\n   - Palette: duplicate keys, invalid hex colors, key length warnings\n   - Sprite: ragged rows, unknown palette keys, frame dimension mismatch, grid size mismatch\n   - Map: unknown tileset keys, ragged rows, malformed sprite references\n   - Track: column count mismatch, invalid notes, unknown patterns in sequence, unknown instruments\n3. Cross-file resolution:\n   - Read .palette files from workspace\n   - Resolve palette references in .sprite files\n   - Resolve sprite references in .map files\n   - Resolve instrument references in .track files\n   - Missing references -> warning (not error)\n4. Error reporting:\n   - Create vscode.Diagnostic for each issue\n   - Set correct range (line, column)\n   - Set severity (Error, Warning, Information)\n   - Include actionable message\n5. Performance optimization:\n   - Debounce validation by 200ms after keystroke\n   - Skip pixel grid coloring for grids >128x128\n   - Cache parsed palette data\n6. Extension settings:\n   - runefact.autoValidateOnSave: boolean\n   - runefact.pixelGridColorMode: \"palette\" | \"hue-rotate\" | \"off\"\n   - runefact.colorDecorators: boolean\n   - runefact.tracker.chromaticColors: boolean\n\nPseudo-code:\n```typescript\nclass RunefactDiagnosticsProvider implements vscode.DocumentDiagnosticProvider {\n  async provideDiagnostics(document: vscode.TextDocument): Promise<vscode.DocumentDiagnostic> {\n    const diagnostics: vscode.Diagnostic[] = [];\n    const content = document.getText();\n    \n    if (document.languageId === 'runefact-sprite') {\n      const errors = this.validateSprite(content);\n      for (const error of errors) {\n        diagnostics.push(new vscode.Diagnostic(\n          new vscode.Range(error.line, error.col, error.line, error.col + error.length),\n          error.message,\n          error.severity === 'error' ? vscode.DiagnosticSeverity.Error : vscode.DiagnosticSeverity.Warning\n        ));\n      }\n    }\n    \n    return new vscode.DocumentDiagnostic(diagnostics);\n  }\n}\n```",
        "testStrategy": "1. Test ragged row in sprite shows error on correct line\n2. Test unknown palette key shows warning\n3. Test invalid hex color shows error\n4. Test frame dimension mismatch shows error\n5. Test unknown tileset key in map shows warning\n6. Test invalid note in track shows error\n7. Test cross-file palette resolution\n8. Test diagnostics appear in Problems panel\n9. Test validation runs on save\n10. Test debouncing prevents excessive validation\n11. Test settings toggle features on/off\n12. Test no false positives on valid demo files",
        "priority": "medium",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement DiagnosticCollection and DocumentDiagnosticProvider Infrastructure",
            "description": "Create src/diagnostics.ts with the core diagnostic infrastructure including DiagnosticCollection setup, DocumentDiagnosticProvider implementation, and registration for all Runefact file types (.palette, .sprite, .map, .track, .inst, .sfx).",
            "dependencies": [],
            "details": "1. Create src/diagnostics.ts with RunefactDiagnosticsProvider class implementing vscode.DocumentDiagnosticProvider\n2. Create a DiagnosticCollection via vscode.languages.createDiagnosticCollection('runefact')\n3. Register the provider for all language IDs: runefact-palette, runefact-sprite, runefact-map, runefact-track, runefact-instrument, runefact-sfx\n4. Implement provideDiagnostics() method that routes to file-type-specific validators based on document.languageId\n5. Register onDidSaveTextDocument listener for validation-on-save (controlled by runefact.autoValidateOnSave setting)\n6. Register onDidChangeTextDocument listener for live validation (with debouncing from subtask 5)\n7. Export activation function to register in extension.ts entry point\n8. Define common ValidationError interface: { line: number, column: number, length: number, message: string, severity: 'error' | 'warning' | 'info' }\n9. Implement helper to convert ValidationError[] to vscode.Diagnostic[] with proper Range and DiagnosticSeverity mapping",
            "status": "pending",
            "testStrategy": "Test that DiagnosticCollection is created and registered correctly. Verify that DocumentDiagnosticProvider is registered for all 6 language IDs. Test that validation triggers on file save when setting is enabled. Test that validation triggers on document change with proper debouncing."
          },
          {
            "id": 2,
            "title": "Implement Per-File-Type Validation Rules",
            "description": "Create validators for each Runefact file type in src/validators/ with comprehensive validation rules for palette, sprite, map, and track files including error/warning severity classification.",
            "dependencies": [
              1
            ],
            "details": "1. Create src/validators/palette.validator.ts:\n   - Detect duplicate color keys -> ERROR\n   - Validate hex color format (^#[0-9a-fA-F]{6}$ or ^#[0-9a-fA-F]{8}$) -> ERROR\n   - Warn on multi-char keys > 4 characters -> WARNING\n   - Parse [colors] TOML table structure\n\n2. Create src/validators/sprite.validator.ts:\n   - Detect ragged rows in pixels blocks (inconsistent width) -> ERROR with line number\n   - Validate grid format (integer or 'WIDTHxHEIGHT' string) -> ERROR\n   - Check frame dimension consistency across animation frames -> ERROR\n   - Verify pixels block dimensions match grid value -> ERROR\n   - Extract palette keys (single chars and [xx] bracket syntax) for cross-file validation\n\n3. Create src/validators/map.validator.ts:\n   - Detect ragged rows in layer grids -> ERROR\n   - Validate tileset reference format ('file:sprite_name') -> ERROR if malformed\n   - Parse [tileset] table and [layer.name] sections\n   - Track tileset keys for unknown key detection\n\n4. Create src/validators/track.validator.ts:\n   - Validate column count consistency in pattern data blocks -> ERROR\n   - Validate note format: [A-G]#?[0-9], ---, ..., ^^^ with optional effects -> ERROR\n   - Count [[channel]] entries and verify pattern columns match\n   - Validate pattern names in [song] sequence exist -> ERROR\n\n5. Create src/parsers/toml.parser.ts with lightweight TOML parsing for validation (or use @iarna/toml npm package)",
            "status": "pending",
            "testStrategy": "Test duplicate palette key detection returns error on correct line. Test invalid hex color format detection. Test ragged row detection in sprites with correct line/column. Test frame dimension mismatch detection. Test track column count validation. Test invalid note format detection. Test pattern sequence validation."
          },
          {
            "id": 3,
            "title": "Implement Cross-File Reference Resolution",
            "description": "Create workspace utilities to resolve palette references in sprites, sprite references in maps, and instrument references in tracks, reporting missing references as warnings.",
            "dependencies": [
              1,
              2
            ],
            "details": "1. Create src/utils/workspace.ts with cross-file resolution utilities:\n   - findPaletteFile(paletteName: string): Promise<vscode.Uri | null> - search workspace for .palette files\n   - findSpriteFile(spritePath: string): Promise<vscode.Uri | null> - resolve 'file:sprite_name' references\n   - findInstrumentFile(instrumentName: string): Promise<vscode.Uri | null> - search for .inst files\n\n2. Create src/utils/paletteCache.ts:\n   - Cache parsed palette data (color key -> hex value mappings)\n   - Invalidate cache on palette file changes (FileSystemWatcher)\n   - getPaletteKeys(paletteName: string): Promise<Set<string>> - return available keys\n\n3. Update sprite.validator.ts:\n   - After extracting palette keys from pixels, cross-reference against resolved palette file\n   - Unknown palette key -> WARNING (not error, as palette may not be resolvable)\n   - Also check palette_extend inline colors if present\n\n4. Update map.validator.ts:\n   - Validate tileset sprite references resolve to actual sprite files\n   - Unknown tileset key in layer grid -> WARNING\n   - Malformed sprite reference -> ERROR\n\n5. Update track.validator.ts:\n   - Validate [[channel]] instrument references resolve to .inst files\n   - Missing instrument -> WARNING\n\n6. Implement workspace.findFiles() patterns for each file type:\n   - Palette: **/*.palette\n   - Sprite: **/*.sprite\n   - Instrument: **/*.inst",
            "status": "pending",
            "testStrategy": "Test palette resolution finds .palette files in workspace. Test sprite reference validation with 'file:sprite_name' format. Test instrument reference validation in track files. Test that missing references produce warnings, not errors. Test palette cache invalidation on file changes. Test cross-file validation works when reference file exists."
          },
          {
            "id": 4,
            "title": "Implement Error Range Calculation for Line/Column Positioning",
            "description": "Implement precise error range calculation to highlight the exact problematic tokens/lines in the editor, with correct line and column positioning for all validation errors.",
            "dependencies": [
              2
            ],
            "details": "1. Create src/utils/rangeCalculator.ts with utilities for precise error positioning:\n   - findLineRange(document: string, lineNumber: number): { start: number, end: number } - get line bounds\n   - findTokenRange(line: string, tokenStart: number, token: string): { column: number, length: number }\n   - findKeyRange(document: string, key: string): vscode.Range - find TOML key position\n\n2. Pixel grid error positioning:\n   - Track line offset from pixels = \"\"\"...\"\"\" start\n   - Calculate column offset for specific character/bracket sequence\n   - For ragged row: highlight the excess/missing characters at end of line\n   - For unknown palette key: highlight the specific character or [xx] bracket\n\n3. TOML structure error positioning:\n   - Duplicate key: highlight the second occurrence\n   - Invalid value: highlight the value portion after '='\n   - Missing section: highlight the reference\n\n4. Pattern data error positioning (tracks):\n   - Column count mismatch: highlight the row with wrong column count\n   - Invalid note: highlight the specific cell (calculate column based on '|' delimiters)\n\n5. Update all validators to return ValidationError with precise line, column, and length:\n   - line: 1-indexed line number in document\n   - column: 0-indexed column position within line\n   - length: number of characters to highlight\n\n6. Ensure vscode.Range creation uses 0-indexed line numbers (convert from 1-indexed validator output)",
            "status": "pending",
            "testStrategy": "Test ragged row error highlights correct line and column range. Test unknown palette key highlights the specific key character/bracket. Test duplicate TOML key highlights the duplicate, not the original. Test invalid hex color highlights the color value. Test track column mismatch highlights the problematic row. Test that all errors appear at correct positions in Problems panel."
          },
          {
            "id": 5,
            "title": "Implement Performance Optimization and Extension Settings",
            "description": "Add performance optimizations including 200ms debouncing, large grid skipping, and palette caching, plus extension settings for configurable validation behavior.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "1. Implement debouncing in diagnostics.ts:\n   - Create debounce utility with 200ms delay for onDidChangeTextDocument\n   - Cancel pending validation if document changes again\n   - Use Map<string, NodeJS.Timeout> keyed by document URI\n\n2. Large grid optimization:\n   - In sprite and map validators, detect grid size before pixel coloring\n   - Skip pixel grid coloring for grids > 128x128 pixels\n   - Still perform structural validation (ragged rows, etc.)\n   - Log info message when skipping for performance\n\n3. Palette caching (enhance from subtask 3):\n   - LRU cache with max 50 palette entries\n   - Cache invalidation on file change via FileSystemWatcher\n   - Cache hit path for rapid repeated validation\n\n4. Add extension settings in package.json contributes.configuration:\n   - runefact.autoValidateOnSave: boolean (default: true) - run validation on file save\n   - runefact.pixelGridColorMode: 'palette' | 'hue-rotate' | 'off' (default: 'palette')\n   - runefact.colorDecorators: boolean (default: true) - show inline color swatches\n   - runefact.tracker.chromaticColors: boolean (default: true) - color notes by pitch\n\n5. Read settings in diagnostics.ts and validators:\n   - Check runefact.autoValidateOnSave before running validation on save\n   - Pass settings to validators that need them\n   - Listen for onDidChangeConfiguration to update behavior\n\n6. Implement validation caching:\n   - Cache validation results keyed by document URI + version\n   - Return cached diagnostics if document unchanged",
            "status": "pending",
            "testStrategy": "Test debouncing delays validation by 200ms after keystrokes. Test rapid typing cancels pending validations. Test large grids (>128x128) skip pixel coloring but still validate structure. Test palette cache is used on repeated validation. Test autoValidateOnSave setting enables/disables save validation. Test settings changes take effect without restart. Test validation caching returns cached results for unchanged documents."
          }
        ]
      },
      {
        "id": 17,
        "title": "VS Code Extension: Commands, Snippets, and CLI Integration",
        "description": "Add VS Code commands for build/validate/preview, code snippets for scaffolding files, and integration with the Runefact CLI.",
        "details": "1. Create src/commands.ts:\n   - Runefact: Build All -> `runefact build`\n   - Runefact: Build Current File Type -> `runefact build --sprites`\n   - Runefact: Validate -> `runefact validate`\n   - Runefact: Preview Current File -> `runefact preview <file>`\n   - Runefact: Open Previewer -> `runefact preview`\n   - Runefact: Initialize Project -> `runefact init`\n2. Terminal integration:\n   - Run commands in VS Code integrated terminal\n   - Focus terminal on command execution\n   - If CLI not installed, show install prompt\n3. Keybindings:\n   - Ctrl+Shift+B: Build All (in Runefact files)\n   - Ctrl+Shift+P: Preview Current File\n4. Create snippets/runefact.code-snippets:\n   - rfpal: palette file skeleton\n   - rfsprite: static sprite definition\n   - rfanim: animated sprite with 2 frames\n   - rfframe: additional animation frame\n   - rfmap: map file with tileset and layer\n   - rfinst: instrument definition\n   - rfsfx: sound effect with one voice\n   - rftrack: track with 2 channels and 1 pattern\n   - rfpat: additional pattern block\n5. CLI path configuration:\n   - runefact.cliPath setting (default: \"runefact\")\n   - Check if CLI exists before running commands\n   - Helpful error if not found\n6. Package and publish:\n   - Bundle with webpack/esbuild\n   - Publish to VS Code Marketplace as \"runefact\"\n   - Also provide .vsix for offline install\n\nSnippet example:\n```json\n{\n  \"rfsprite\": {\n    \"prefix\": \"rfsprite\",\n    \"body\": [\n      \"palette = \\\"${1:default}\\\"\",\n      \"grid = ${2:16}\",\n      \"\",\n      \"[sprite.${3:name}]\",\n      \"pixels = \\\"\\\"\\\"\",\n      \"${4:________________}\",\n      \"${5:________________}\",\n      \"\\\"\\\"\\\"\"\n    ],\n    \"description\": \"New static sprite definition\"\n  }\n}\n```",
        "testStrategy": "1. Test each command runs correct CLI command\n2. Test commands appear in command palette\n3. Test keybindings trigger commands\n4. Test snippets expand correctly\n5. Test CLI path setting is respected\n6. Test missing CLI shows helpful error\n7. Test commands work when CLI is installed\n8. Test extension bundles correctly\n9. Test .vsix installs in VS Code\n10. Test extension works in Cursor/Windsurf",
        "priority": "medium",
        "dependencies": [
          16
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement VS Code Commands for CLI Integration",
            "description": "Create src/commands.ts with all Runefact commands that execute CLI operations: Build All, Build Current File Type, Validate, Preview Current File, Open Previewer, and Initialize Project.",
            "dependencies": [],
            "details": "1. Create src/commands.ts with command implementations:\n   - `runefact.buildAll`: Execute `runefact build` in terminal\n   - `runefact.buildType`: Detect current file type and run `runefact build --sprites|--maps|--audio`\n   - `runefact.validate`: Execute `runefact validate`\n   - `runefact.previewFile`: Get active file path and run `runefact preview <filepath>`\n   - `runefact.openPreviewer`: Execute `runefact preview` (no args)\n   - `runefact.init`: Execute `runefact init`\n2. Register all commands in package.json contributes.commands array\n3. Add activation events for command invocation\n4. Add keybindings in package.json:\n   - Ctrl+Shift+B for buildAll (when in Runefact files)\n   - Ctrl+Shift+P for previewFile (separate from command palette)\n5. Add command palette entries with proper titles prefixed with 'Runefact:'",
            "status": "pending",
            "testStrategy": "Test each command appears in command palette. Verify commands execute correct CLI strings. Test keybindings trigger appropriate commands when editing Runefact files. Test buildType correctly detects file extension and maps to correct build flag."
          },
          {
            "id": 2,
            "title": "Terminal Integration with Focus Handling and CLI Detection",
            "description": "Implement terminal management for running CLI commands with proper focus handling, CLI existence checking, and helpful error messages when CLI is not installed.",
            "dependencies": [
              1
            ],
            "details": "1. Create terminal utility functions in src/terminal.ts:\n   - `getOrCreateTerminal()`: Reuse existing Runefact terminal or create new one\n   - `runCommand(cmd: string)`: Send command to terminal and focus it\n   - `checkCliExists()`: Verify CLI is accessible at configured path\n2. Implement CLI path configuration:\n   - Add `runefact.cliPath` setting in package.json contributes.configuration\n   - Default value: 'runefact' (assumes in PATH)\n   - Read setting in commands before execution\n3. Add CLI existence check before running commands:\n   - Use `which runefact` (Unix) or `where runefact` (Windows)\n   - Cache result to avoid repeated checks\n   - Show informative error dialog if not found with install instructions\n4. Terminal behavior:\n   - Focus terminal after sending command\n   - Use consistent terminal name 'Runefact'\n   - Preserve terminal between command invocations",
            "status": "pending",
            "testStrategy": "Test terminal is created and focused on first command. Test terminal is reused on subsequent commands. Test missing CLI shows error dialog with helpful message. Test custom cliPath setting is respected. Test cross-platform path checking works."
          },
          {
            "id": 3,
            "title": "Create Code Snippets for All Runefact File Types",
            "description": "Define VS Code snippets for scaffolding all Runefact file types: palette (rfpal), sprites (rfsprite, rfanim, rfframe), maps (rfmap), instruments (rfinst), sound effects (rfsfx), and tracks (rftrack, rfpat).",
            "dependencies": [],
            "details": "1. Create snippets/runefact.code-snippets with all snippet definitions:\n   - rfpal: Complete palette file with sample colors and keys\n   - rfsprite: Static sprite with palette reference, grid, and pixel block\n   - rfanim: Animated sprite with 2 frames and duration\n   - rfframe: Additional animation frame to add to existing sprite\n   - rfmap: Map file with tileset reference, dimensions, and layer data\n   - rfinst: Instrument definition with oscillator and envelope settings\n   - rfsfx: Sound effect with one voice and effect parameters\n   - rftrack: Track file with tempo, 2 channels, and 1 pattern\n   - rfpat: Additional pattern block for tracks\n2. Use tab stops ($1, $2, etc.) for editable sections\n3. Include placeholder values that demonstrate correct syntax\n4. Register snippets in package.json for each file type association\n5. Add meaningful descriptions for each snippet",
            "status": "pending",
            "testStrategy": "Test each snippet prefix triggers in command palette. Verify snippet expansion produces valid syntax for each file type. Test tab stops navigate through editable sections correctly. Test snippets only appear for appropriate file types."
          },
          {
            "id": 4,
            "title": "Bundle Extension with Webpack/esbuild for Publishing",
            "description": "Configure bundling with webpack or esbuild for production build, update package.json for marketplace publishing, and create .vsix packaging for offline installation.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "1. Add bundler configuration (esbuild preferred for speed):\n   - Create esbuild.js or webpack.config.js\n   - Configure entry point as src/extension.ts\n   - Output to dist/extension.js\n   - Externalize 'vscode' module\n   - Enable minification for production\n   - Generate source maps for debugging\n2. Update package.json for publishing:\n   - Set main to './dist/extension.js'\n   - Add publisher field (e.g., 'runefact')\n   - Add repository, icon, and categories fields\n   - Add engines.vscode minimum version\n   - Configure .vscodeignore to exclude source files\n3. Add npm scripts:\n   - 'compile': Run bundler in development mode\n   - 'package': Run vsce package to create .vsix\n   - 'publish': Run vsce publish to marketplace\n4. Create .vscodeignore to exclude dev files from package\n5. Document publishing process in extension README",
            "status": "pending",
            "testStrategy": "Test bundled extension loads correctly in VS Code. Verify .vsix installs and works offline. Test all features work in bundled version. Verify package size is reasonable. Test publishing dry-run with vsce."
          }
        ]
      },
      {
        "id": 18,
        "title": "Usage Documentation Suite",
        "description": "Create comprehensive documentation covering installation, quickstart, format references, authoring guides, ebitengine integration, and AI workflow patterns.",
        "details": "1. Create docs/ directory structure:\n   - getting-started.md: installation + quickstart\n   - format-reference.md: complete format specs\n   - sprite-guide.md: sprite authoring deep dive\n   - map-guide.md: map authoring deep dive\n   - audio-guide.md: SFX and music authoring\n   - ebitengine-integration.md: loading artifacts in games\n   - ai-workflows.md: working with Claude + MCP\n   - mcp-reference.md: MCP tool/resource reference\n2. getting-started.md:\n   - Installation: go install, binary releases, Homebrew\n   - Quickstart: init, build, preview in 5 minutes\n   - Project layout explanation\n3. format-reference.md:\n   - For each format: purpose, complete schema, all fields with types/defaults\n   - Minimal valid example + full-featured example\n   - Common mistakes and fixes\n4. Authoring guides:\n   - Sprite: palette design, pixel grids, animation guidelines\n   - Map: tileset design, layers, entities\n   - Audio: waveforms, envelopes, SFX categories, tracker format\n5. ebitengine-integration.md:\n   - Loading manifest, sprite sheets, maps, audio\n   - Complete buildable main.go example game\n   - Animation, input, audio playback\n6. AI workflow docs:\n   - MCP setup for Claude Code/Desktop\n   - Workflow patterns with example conversations\n   - Agent best practices\n7. CLAUDE.md:\n   - Concise cheat sheet for agent context\n   - Quick reference for tools, formats, rules\n8. `runefact docs` command:\n   - Print path to docs directory\n\nExample game (ebitengine-integration.md):\n```go\npackage main\n\nimport (\n    \"github.com/hajimehoshi/ebiten/v2\"\n    \"your-game/build/assets\"\n)\n\nfunc main() {\n    // Load sprite sheet\n    img, _ := ebiten.NewImageFromFile(assets.SpriteSheetPlayer)\n    \n    // Get sprite info\n    info := assets.Sprites[\"player:idle\"]\n    \n    // Draw sprite\n    // ...\n}\n```",
        "testStrategy": "1. Follow getting-started.md from fresh install -> working demo\n2. Validate format-reference.md examples all build successfully\n3. Follow sprite-guide.md to create new sprite\n4. Follow map-guide.md to create new level\n5. Follow audio-guide.md to create SFX and music\n6. Build and run example game from ebitengine-integration.md\n7. Test CLAUDE.md provides useful agent context\n8. Test `runefact docs` prints correct path\n9. Check all docs render correctly on GitHub\n10. Review by someone unfamiliar with Runefact",
        "priority": "medium",
        "dependencies": [
          14
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Getting Started Guide with Installation and Quickstart",
            "description": "Write docs/getting-started.md covering installation methods (go install, binary releases, Homebrew), a 5-minute quickstart tutorial, and project layout explanation with practical examples.",
            "dependencies": [],
            "details": "Create docs/getting-started.md with the following structure:\n\n1. **Installation section:**\n   - go install github.com/runefact/runefact/cmd/runefact@latest\n   - Binary releases download instructions (Linux, macOS, Windows)\n   - Homebrew tap: brew install runefact/tap/runefact\n   - Verify installation: runefact --version\n\n2. **5-Minute Quickstart:**\n   - mkdir my-game && cd my-game\n   - runefact init (creates runefact.toml and assets/ structure)\n   - Create a simple palette file (assets/palettes/default.palette)\n   - Create a minimal sprite (assets/sprites/player.sprite)\n   - runefact build\n   - runefact preview to see results\n   - All examples must be copy-paste ready\n\n3. **Project Layout:**\n   - Explain runefact.toml structure ([project], [defaults], [preview])\n   - Describe assets/ directory conventions\n   - Explain build/assets/ output structure\n   - Show manifest.go purpose for ebitengine integration\n\n4. **Next Steps:**\n   - Links to format-reference.md, sprite-guide.md, etc.\n   - Mention VS Code extension and MCP server\n\nAll commands must be tested to ensure they work on a fresh system.",
            "status": "pending",
            "testStrategy": "1. Follow the guide from scratch on a clean system without Runefact installed\n2. Verify all installation methods work (go install at minimum)\n3. Test every command in the quickstart section sequentially\n4. Confirm runefact init creates expected files\n5. Confirm runefact build produces output\n6. Confirm runefact preview launches without errors\n7. Have a second person follow the guide to identify unclear steps"
          },
          {
            "id": 2,
            "title": "Write Complete Format Reference Documentation",
            "description": "Create docs/format-reference.md with complete TOML schemas for all six file formats (.palette, .sprite, .map, .inst, .sfx, .track), including field types, defaults, minimal and full examples.",
            "dependencies": [
              1
            ],
            "details": "Create docs/format-reference.md structured as a comprehensive reference:\n\n1. **For each format (.palette, .sprite, .map, .inst, .sfx, .track):**\n   - Purpose and use case summary\n   - Complete schema table with all fields:\n     - Field name, type, required/optional, default value, description\n   - Minimal valid example (smallest working file)\n   - Full-featured example showing all options\n   - Common mistakes and how to fix them\n\n2. **Palette format (.palette):**\n   - name field, [colors] table\n   - Single-char vs multi-char keys, _ for transparent\n   - Color values: hex (#rrggbb), named (transparent)\n\n3. **Sprite format (.sprite):**\n   - palette reference, grid size (square or WxH)\n   - [sprite.name] sections, pixels multiline strings\n   - Animation: framerate, [[sprite.name.frame]] arrays\n   - palette_extend for inline additions\n   - Bracket [xx] syntax for multi-char keys in grids\n\n4. **Map format (.map):**\n   - tile_size, [tileset] mapping, [layer.name] sections\n   - Tile layers with pixels grids\n   - Entity layers with [[layer.name.entity]] arrays\n   - Scroll factors, properties objects\n\n5. **Instrument format (.inst):**\n   - [oscillator], [envelope], [filter], [effects] sections\n   - Waveform types, ADSR parameters, filter types\n\n6. **SFX format (.sfx):**\n   - duration, volume, [[voice]] arrays\n   - Per-voice envelope, pitch sweep, filter sweep\n\n7. **Track format (.track):**\n   - tempo, ticks_per_beat, loop settings\n   - [[channel]] with instrument ref, volume\n   - Pattern syntax (notes, rests, effects)\n\nAll examples must be buildable with runefact build.",
            "status": "pending",
            "testStrategy": "1. Create a test project with one file of each format using the minimal examples\n2. Run runefact build and verify all compile without errors\n3. Create a second test project with full-featured examples\n4. Run runefact build and verify all compile\n5. Intentionally introduce the 'common mistakes' and verify error messages match documentation\n6. Cross-reference schemas against actual parser implementations in internal/ packages"
          },
          {
            "id": 3,
            "title": "Develop Authoring Guides for Sprites, Maps, and Audio",
            "description": "Create three detailed authoring guides (sprite-guide.md, map-guide.md, audio-guide.md) with best practices, design patterns, workflow tips, and practical examples for creating each asset type.",
            "dependencies": [
              2
            ],
            "details": "Create three comprehensive authoring guides in docs/:\n\n**1. docs/sprite-guide.md:**\n- Palette design philosophy (limited colors, naming conventions)\n- Designing pixel grids: starting from scratch vs converting art\n- Grid size selection (8x8, 16x16, 32x32 trade-offs)\n- Animation principles: frame counts, timing, looping\n- Sprite sheet organization: grouping related sprites\n- Example workflow: creating a character with idle, walk, jump animations\n- Tips for LLM authoring: clear prompts, iteration strategies\n- Troubleshooting: ragged rows, palette mismatches, dimension errors\n\n**2. docs/map-guide.md:**\n- Tileset design: creating modular, reusable tiles\n- Layer organization: background, main, foreground, objects\n- Parallax scrolling setup with scroll_x/scroll_y\n- Entity placement: spawns, collectibles, enemies, triggers\n- Entity properties for game logic\n- Large map strategies: chunking, seamless transitions\n- Example: building a platformer level from scratch\n- Example: building an RPG overworld\n\n**3. docs/audio-guide.md:**\n- Waveform selection guide (when to use sine vs square vs noise)\n- ADSR envelope design for different sound types\n- SFX categories with starting parameters:\n  - UI sounds (clicks, confirms)\n  - Player actions (jump, attack, damage)\n  - Environmental (ambient, impacts)\n  - Collectibles (coins, powerups)\n- Filter usage for texture and movement\n- Tracker pattern basics: note notation, effects\n- Composing loops: drum patterns, bass lines, melodies\n- Mixing: volume balancing across channels\n- Example: creating a complete game audio set (5 SFX + 1 track)",
            "status": "pending",
            "testStrategy": "1. Follow sprite-guide.md to create a new character sprite from scratch\n2. Verify the created sprite builds and previews correctly\n3. Follow map-guide.md to create a test level\n4. Verify the map JSON output is valid and complete\n5. Follow audio-guide.md to create an SFX and a music track\n6. Verify audio files play correctly in the previewer\n7. Test all examples with runefact build && runefact preview"
          },
          {
            "id": 4,
            "title": "Create Ebitengine Integration Guide with Complete Example Game",
            "description": "Write docs/ebitengine-integration.md showing how to load and use Runefact artifacts in an ebitengine game, including a complete, buildable main.go example with sprites, maps, animation, input, and audio playback.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create docs/ebitengine-integration.md with:\n\n**1. Manifest Overview:**\n- Explain manifest.go structure and generated constants\n- Sprite sheet paths, sprite metadata (position, frames, framerate)\n- Map JSON paths, audio WAV paths\n- Type-safe asset references\n\n**2. Loading Assets:**\n- Loading sprite sheets with ebiten.NewImageFromFile\n- Parsing sprite metadata for drawing sub-images\n- Loading map JSON with encoding/json\n- Loading audio with audio.NewPlayer\n\n**3. Complete Example Game (main.go):**\n```go\npackage main\n\nimport (\n    \"github.com/hajimehoshi/ebiten/v2\"\n    \"github.com/hajimehoshi/ebiten/v2/audio\"\n    // imports for your-game/build/assets\n)\n\ntype Game struct {\n    playerX, playerY float64\n    frame int\n    spriteSheet *ebiten.Image\n    audioContext *audio.Context\n    jumpSound *audio.Player\n}\n\nfunc (g *Game) Update() error { /* input handling, animation */ }\nfunc (g *Game) Draw(screen *ebiten.Image) { /* sprite drawing, map rendering */ }\nfunc main() { /* init and run */ }\n```\n\n**4. Sections to cover:**\n- Drawing static sprites\n- Animating sprites (frame cycling based on framerate)\n- Rendering tile maps layer by layer\n- Handling entity data from map JSON\n- Input handling (move character, trigger actions)\n- Playing sound effects on events\n- Playing background music with looping\n\n**5. Asset organization patterns:**\n- Recommended project structure\n- Build integration (go generate, Makefile)\n- Hot-reload during development with runefact watch\n\nThe main.go must be complete and buildable with appropriate Runefact assets.",
            "status": "pending",
            "testStrategy": "1. Create a test ebitengine project with sample Runefact assets\n2. Copy the complete main.go example into the project\n3. Run go build and verify it compiles without errors\n4. Run the game and verify:\n   - Sprite sheet loads and displays correctly\n   - Animation plays at correct framerate\n   - Map renders with all layers\n   - Input moves the character\n   - Sound effects play on actions\n   - Background music loops\n5. Test on multiple platforms (Linux, macOS, Windows) if possible"
          },
          {
            "id": 5,
            "title": "Document AI Workflows, MCP Reference, and CLAUDE.md Agent Context",
            "description": "Create ai-workflows.md with MCP setup instructions and conversation patterns, mcp-reference.md with complete tool/resource documentation, and update CLAUDE.md as a concise agent context cheat sheet.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create three documentation files for AI-assisted development:\n\n**1. docs/ai-workflows.md:**\n- MCP server setup for Claude Code:\n  - Adding to .mcp.json configuration\n  - runefact mcp command and stdio transport\n- MCP server setup for Claude Desktop:\n  - Configuration file location and format\n- Workflow patterns with example conversations:\n  - \"Create a player sprite\"  tool calls, iterations\n  - \"Add a jump sound effect\"  inspect existing, create new\n  - \"Build a level using existing tiles\"  resource reads, create map\n  - \"Fix validation errors\"  validate, read diagnostics, edit\n- Agent best practices:\n  - Use inspect tools before creating assets\n  - Validate after changes\n  - Iterate on parameters conversationally\n  - Reference format docs via MCP resources\n\n**2. docs/mcp-reference.md:**\n- Complete tool reference (one section per tool):\n  - build: parameters, returns, example\n  - validate: parameters, returns, example\n  - inspect: parameters (file path), returns (parsed AST)\n  - create-asset: parameters, templates\n  - preview-url: returns preview server URL\n- Complete resource reference:\n  - format://palette, format://sprite, etc. (format specs)\n  - project://config (current runefact.toml)\n  - project://assets (list of all asset files)\n- Error handling patterns\n- Rate limiting considerations\n\n**3. Update root CLAUDE.md:**\n- Keep it concise (agent context file, not full docs)\n- Quick reference sections:\n  - Available CLI commands (one-liner each)\n  - File format cheat sheet (key fields only)\n  - MCP tool names and purposes\n  - Common validation rules\n- Link to full docs/ for details\n- Audio safety reminders (never auto-play, limiter always on)",
            "status": "pending",
            "testStrategy": "1. Test MCP setup instructions with Claude Code in a fresh project\n2. Verify runefact mcp starts and responds to tool calls\n3. Execute each documented tool via MCP and compare output to docs\n4. Read each documented resource and verify format matches docs\n5. Role-play the example conversations and verify tools work as described\n6. Load CLAUDE.md as agent context and verify it provides sufficient information for basic operations without needing full docs\n7. Test that CLAUDE.md quick references are accurate and current"
          }
        ]
      },
      {
        "id": 19,
        "title": "Demo Assets and Acceptance Test Suite",
        "description": "Create the complete Rune Knight demo asset set (palettes, sprites, maps, instruments, SFX, music) that serves as both example content and acceptance test suite for all features.",
        "details": "1. Create demo assets from PRD specification:\n   - palettes/default.palette: 16-color palette\n   - sprites/player.sprite: idle, walk, jump, heart, coin\n   - sprites/tiles.sprite: grass, dirt, stone, sky, cloud, water\n   - sprites/enemies.sprite: slime with multi-char palette keys\n   - maps/level1.map: 4 layers with parallax, entities\n   - instruments/: sfx_basic, sfx_noise, lead, bass, kick, hihat, pad\n   - sounds/: jump, coin, hurt, explosion, powerup, death\n   - music/theme.track: 4-pattern loop with 4 channels\n   - music/gameover.track: non-looping jingle with volume effects\n2. runefact.toml for demo:\n   - Project name: rune-knight\n   - All default settings configured\n3. Create test harness:\n   - Build all demo assets, verify no errors\n   - Compare output to expected (golden files or checksums)\n   - Test each phase demo subset\n4. Acceptance test checklist:\n   - Phase 1: sprites produce correct PNGs\n   - Phase 2: previewer shows sprites, animations work\n   - Phase 3: maps produce correct JSON\n   - Phase 4: SFX produce playable WAVs\n   - Phase 5: tracks produce playable music\n   - Phase 6-7: VS Code highlights correctly\n   - Phase 8: docs walkthrough works\n   - Phase 9: MCP agent conversation works\n5. CI integration:\n   - Automated test running demo build\n   - Fail if any demo asset fails to build\n\nTest structure:\n```go\nfunc TestDemoAssets(t *testing.T) {\n    // Init demo project\n    dir := t.TempDir()\n    runInit(dir)\n    \n    // Build all\n    result, err := build.Build(build.Options{}, config.Load(dir))\n    require.NoError(t, err)\n    require.Empty(t, result.Errors)\n    \n    // Verify outputs exist\n    assert.FileExists(t, filepath.Join(dir, \"build/assets/sprites/player.png\"))\n    assert.FileExists(t, filepath.Join(dir, \"build/assets/maps/level1.json\"))\n    assert.FileExists(t, filepath.Join(dir, \"build/assets/audio/jump.wav\"))\n    assert.FileExists(t, filepath.Join(dir, \"build/assets/audio/theme.wav\"))\n    assert.FileExists(t, filepath.Join(dir, \"build/assets/manifest.go\"))\n}\n```",
        "testStrategy": "1. `runefact init` creates all demo files\n2. `runefact build` succeeds with no errors\n3. All expected output files exist\n4. PNG sprite sheets have correct dimensions\n5. JSON maps have correct structure\n6. WAV files are playable\n7. manifest.go compiles\n8. Previewer displays all demo assets\n9. VS Code extension highlights demo files correctly\n10. MCP tools work with demo project\n11. CI pipeline runs tests on every commit",
        "priority": "medium",
        "dependencies": [
          10,
          13,
          17,
          18
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Demo Palette and Sprite Files",
            "description": "Create the core visual assets: default.palette with 16 colors, player.sprite with idle/walk/jump/heart/coin animations, tiles.sprite with terrain blocks, and enemies.sprite demonstrating multi-char palette keys.",
            "dependencies": [],
            "details": "Create palettes/default.palette with 16 colors following PRD spec (transparent, black, white, red, green, blue, yellow, cyan, magenta, orange, brown, pink, lime, sky, gray, dark gray). Create sprites/player.sprite with 16x16 grid containing idle (1 frame), walk (4 frames at 8fps), jump (2 frames), plus 8x8 heart and coin collectibles. Create sprites/tiles.sprite with 16x16 blocks for grass, dirt, stone, sky, cloud, water (static frames). Create sprites/enemies.sprite with slime enemy using multi-char palette keys like [sk] for slime-skin to demonstrate bracket syntax. All sprites reference default.palette and use _ for transparency. Include inline palette_extend where needed for sprite-specific colors.",
            "status": "pending",
            "testStrategy": "Verify all .palette and .sprite files parse without errors using runefact validate. Build sprites and confirm PNG outputs have correct dimensions (player.png width = frames * 16, tiles.png has all 6 tile types). Visually inspect rendered sprites match intended pixel art. Test multi-char key parsing works in enemies.sprite."
          },
          {
            "id": 2,
            "title": "Create Demo Map File with Layers and Entities",
            "description": "Create level1.map with 4 layers (background, midground, foreground, collision), parallax scrolling configuration, and entity placements for player spawn, enemies, and collectibles.",
            "dependencies": [
              1
            ],
            "details": "Create maps/level1.map with 20x15 tile grid (320x240 pixels at 16x16). Define 4 layers: background (sky, clouds with parallax 0.5), midground (distant terrain with parallax 0.8), foreground (main gameplay terrain with parallax 1.0), collision (binary collision mask). Reference tiles.sprite for tile definitions. Add entities section with player spawn point, 3 slime enemy placements referencing enemies.sprite, and 5 coin collectibles. Configure layer parallax values in layer metadata. Use bracket syntax for multi-char tile keys where appropriate. Include map metadata: name, author, tileset reference.",
            "status": "pending",
            "testStrategy": "Verify level1.map parses without errors. Build and confirm JSON output contains all 4 layers with correct dimensions. Validate entity positions are within map bounds. Check parallax values are preserved in JSON output. Load JSON in a test ebitengine program to verify structure compatibility."
          },
          {
            "id": 3,
            "title": "Create Demo Audio Files (Instruments, SFX, Tracks)",
            "description": "Create complete audio asset set: 7 instrument definitions, 6 sound effects, and 2 music tracks demonstrating all audio features including synthesis, effects, and tracker patterns.",
            "dependencies": [],
            "details": "Create instruments/: sfx_basic.inst (square wave for SFX), sfx_noise.inst (noise generator), lead.inst (saw wave with filter), bass.inst (sine/square hybrid), kick.inst (pitch envelope percussion), hihat.inst (noise with decay), pad.inst (detuned saws with slow attack). Create sounds/: jump.sfx (pitch up sweep), coin.sfx (two-tone arpeggio), hurt.sfx (noise burst with pitch down), explosion.sfx (layered noise), powerup.sfx (ascending arpeggio), death.sfx (descending pitch with reverb). Create music/theme.track: 4-pattern loop, 120 BPM, 4 channels (lead melody, bass line, kick/hihat rhythm, pad chords). Create music/gameover.track: non-looping 8-bar jingle with volume fade effects and tempo change.",
            "status": "pending",
            "testStrategy": "Verify all .inst, .sfx, and .track files parse without errors. Build and confirm WAV outputs exist for all 6 SFX and 2 tracks. Verify WAV files are playable (non-zero length, valid headers). Check audio passes brickwall limiter (no clipping above -1dBFS). Listen to outputs to verify they sound intentional (no harsh noise, clicks, or silence)."
          },
          {
            "id": 4,
            "title": "Implement Test Harness for Demo Asset Builds",
            "description": "Create comprehensive test harness that initializes demo project, builds all assets, verifies no errors, and confirms all expected output files exist with correct properties.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create internal/demo/demo_test.go with TestDemoAssets function. Test flow: 1) Create temp directory, 2) Run runefact init to populate demo files, 3) Load config and call build.Build(), 4) Assert no build errors, 5) Verify file existence for all expected outputs: build/assets/sprites/player.png, tiles.png, enemies.png; build/assets/maps/level1.json; build/assets/audio/jump.wav, coin.wav, hurt.wav, explosion.wav, powerup.wav, death.wav, theme.wav, gameover.wav; build/assets/manifest.go. Add property checks: PNG dimensions match expected (image.DecodeConfig), JSON structure validates against schema, WAV headers indicate valid audio, manifest.go compiles with go build. Create helper functions for common assertions.",
            "status": "pending",
            "testStrategy": "Run go test ./internal/demo/... and verify all assertions pass. Test should complete in under 30 seconds. Deliberately break a demo asset and verify test catches the error. Test both success and failure paths. Verify test cleans up temp directories properly."
          },
          {
            "id": 5,
            "title": "CI Integration with Golden Files and Phase Acceptance Tests",
            "description": "Set up CI workflow that runs demo build tests, compares outputs against golden files or checksums, and validates each project phase's acceptance criteria.",
            "dependencies": [
              4
            ],
            "details": "Create .github/workflows/demo-assets.yml for CI. Store golden files in testdata/golden/: checksums for WAV files (content may vary slightly), PNG files for exact comparison, JSON files for structure comparison. Implement comparison strategy: PNG uses byte-exact comparison (deterministic rendering), WAV uses duration/sample-rate check (synthesis may have minor variations), JSON uses semantic comparison (ignore whitespace). Create phase-specific acceptance tests: Phase 1 (sprites produce PNGs), Phase 2 (previewer loads without crash - headless check), Phase 3 (maps produce valid JSON), Phase 4 (SFX produce playable WAVs), Phase 5 (tracks produce music WAVs), Phase 6-7 (VS Code grammar files exist and are valid), Phase 8 (docs examples are buildable), Phase 9 (MCP server starts and responds). Add CI job that runs on PR and push to main. Fail build if any demo asset fails or golden comparison mismatches.",
            "status": "pending",
            "testStrategy": "Push changes and verify CI workflow triggers and passes. Deliberately modify a golden file and verify CI catches the mismatch. Test each phase acceptance check independently. Verify CI provides clear error messages on failure. Test workflow runs in under 2 minutes."
          }
        ]
      },
      {
        "id": 20,
        "title": "Polish and Production Readiness",
        "description": "Final polish including better error messages, performance optimization, caching for incremental builds, comprehensive edge case handling, and release preparation.",
        "details": "1. Error message improvements:\n   - Include file:line:col for all errors\n   - Suggest fixes for common mistakes\n   - Use Levenshtein distance for \"did you mean X?\" suggestions\n   - Color-coded output in terminal (if supported)\n2. Performance optimization:\n   - Parallel compilation of independent files\n   - File-level caching: skip unchanged files\n   - Hash-based cache invalidation\n   - Benchmark large projects (100+ assets)\n3. Edge case handling:\n   - File encoding: require UTF-8, error otherwise\n   - Output directory not writable: fail early\n   - Circular palette references: detect and error\n   - Very large maps (>1000x1000): viewport culling\n   - Very large sprite grids: performance limits\n4. CLI polish:\n   - Progress indicators for long operations\n   - `--verbose` flag for detailed output\n   - `--quiet` flag for CI usage\n   - `--version` flag\n   - Colored output with `--no-color` override\n5. Release preparation:\n   - GitHub Actions CI/CD pipeline\n   - Binary releases for macOS (arm64, amd64), Linux, Windows\n   - Homebrew tap setup\n   - VS Code extension publishing to Marketplace\n   - README with badges, screenshots\n   - CHANGELOG.md\n6. Final validation:\n   - Full test suite passes\n   - Demo project builds successfully\n   - All docs accurate and tested\n   - MCP integration verified\n   - VS Code extension works in target editors\n\nPerformance caching:\n```go\ntype BuildCache struct {\n    Hashes map[string]string // file path -> content hash\n    path   string\n}\n\nfunc (c *BuildCache) NeedsRebuild(file string) bool {\n    content, _ := os.ReadFile(file)\n    hash := sha256.Sum256(content)\n    hashStr := hex.EncodeToString(hash[:])\n    \n    if c.Hashes[file] == hashStr {\n        return false\n    }\n    c.Hashes[file] = hashStr\n    return true\n}\n```",
        "testStrategy": "1. Test error messages include file/line references\n2. Test \"did you mean\" suggestions work correctly\n3. Benchmark: 100 sprite files build in <10s\n4. Test file caching skips unchanged files\n5. Test parallel compilation doesn't cause race conditions\n6. Test UTF-8 encoding validation\n7. Test output directory permission handling\n8. Test circular reference detection\n9. Test large map handling\n10. Test all CLI flags work correctly\n11. Test CI pipeline succeeds\n12. Test binary releases work on all platforms\n13. End-to-end test: fresh install to running game",
        "priority": "low",
        "dependencies": [
          19
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement enhanced error messages with file:line:col references and suggestions",
            "description": "Add detailed error location tracking and 'did you mean' suggestions using Levenshtein distance for common mistakes like typos in palette keys, asset references, and TOML field names.",
            "dependencies": [],
            "details": "1. Create internal/errors/diagnostic.go with Diagnostic struct:\n   - File, Line, Column fields for precise location\n   - Message, Suggestion, Code fields\n   - Severity enum (Error, Warning, Hint)\n\n2. Implement Levenshtein distance helper for suggestions:\n   - Calculate edit distance between strings\n   - Find closest matches from valid options (palette keys, field names)\n   - Threshold: suggest if distance <= 2 for short strings, <= 3 for longer\n\n3. Update all parsers to track line/column:\n   - Wrap TOML decode errors with file position\n   - Track line numbers in pixel grid parsing\n   - Include context in bracket-syntax parsing errors\n\n4. Implement color-coded terminal output:\n   - Use fatih/color or similar for cross-platform support\n   - Red for errors, yellow for warnings, cyan for suggestions\n   - Detect terminal capability, disable color when piping\n\n5. Create error formatter:\n   - Format: 'file.sprite:15:8: error: unknown palette key 'bue' (did you mean 'blu'?)'\n   - Show source line with caret pointing to error position\n   - Group related errors by file",
            "status": "pending",
            "testStrategy": "1. Test Levenshtein distance calculation correctness\n2. Test 'did you mean' triggers for close typos (1-2 edits)\n3. Test no suggestion for distant strings (>3 edits)\n4. Test error messages include correct file:line:col\n5. Test color output respects terminal capability\n6. Test error formatting matches expected output format"
          },
          {
            "id": 2,
            "title": "Implement parallel compilation and hash-based file caching",
            "description": "Add performance optimizations including parallel processing of independent asset files and SHA256-based caching to skip unchanged files during incremental builds.",
            "dependencies": [
              1
            ],
            "details": "1. Create internal/build/cache.go with BuildCache:\n   - Hashes map[string]string for file path -> content hash\n   - CachePath string for persistence location (.runefact-cache)\n   - Load/Save methods for JSON serialization\n   - NeedsRebuild(file string) bool using SHA256 comparison\n\n2. Implement parallel file compilation:\n   - Use worker pool pattern with configurable concurrency\n   - Default workers = runtime.NumCPU()\n   - Channel-based work distribution\n   - Collect results and errors safely with mutex\n\n3. Ensure thread-safe operations:\n   - Palette resolution must complete before sprites/maps (sequential phase)\n   - Sprites, maps, and audio compile in parallel within their phases\n   - Use sync.WaitGroup for coordination\n   - Protect shared state (errors slice, manifest data)\n\n4. Implement cache invalidation:\n   - Invalidate sprite if referenced palette changes\n   - Track dependency graph for proper invalidation\n   - --no-cache flag to force full rebuild\n\n5. Benchmark infrastructure:\n   - Create benchmark test with 100+ generated assets\n   - Measure cold build vs cached build times\n   - Target: 100 sprites in <10s, cache hits in <1s",
            "status": "pending",
            "testStrategy": "1. Test cache correctly identifies unchanged files\n2. Test cache invalidates when file content changes\n3. Test parallel compilation produces same output as sequential\n4. Test no race conditions with -race flag\n5. Test dependent files invalidate correctly\n6. Benchmark 100+ assets completes in <10s\n7. Test --no-cache forces full rebuild"
          },
          {
            "id": 3,
            "title": "Implement comprehensive edge case handling",
            "description": "Add robust handling for edge cases including UTF-8 encoding validation, permission checks, circular reference detection, and performance limits for large assets.",
            "dependencies": [],
            "details": "1. UTF-8 encoding validation:\n   - Check BOM presence (warn if found, handle gracefully)\n   - Validate all bytes are valid UTF-8 sequences\n   - Use utf8.Valid() from stdlib\n   - Clear error message suggesting file re-encoding if invalid\n\n2. Output directory validation:\n   - Check directory exists or can be created\n   - Check write permissions before starting build\n   - Fail fast with actionable error message\n   - Create parent directories if needed (like mkdir -p)\n\n3. Circular palette reference detection:\n   - Build dependency graph during palette parsing\n   - Use DFS to detect cycles\n   - Report cycle path in error: 'circular reference: a.palette -> b.palette -> a.palette'\n\n4. Large map handling:\n   - Define limits: warn at 1000x1000, error at 10000x10000\n   - Estimate memory usage and warn if excessive\n   - Suggest viewport culling in warning message\n   - Add --force flag to override limits\n\n5. Large sprite grid limits:\n   - Warn for grids > 256x256 pixels per frame\n   - Warn for sprite sheets > 100 frames\n   - Memory estimation for final PNG output\n\n6. General robustness:\n   - Handle missing referenced files gracefully\n   - Validate numeric ranges (dimensions, durations, etc.)\n   - Check disk space before writing large outputs",
            "status": "pending",
            "testStrategy": "1. Test UTF-8 validation rejects invalid sequences\n2. Test BOM handling (accept with warning)\n3. Test output directory permission check fails appropriately\n4. Test circular palette detection finds cycles\n5. Test large map warning triggers at threshold\n6. Test --force overrides size limits\n7. Test missing file references produce clear errors"
          },
          {
            "id": 4,
            "title": "Add CLI polish with progress indicators and output control flags",
            "description": "Enhance the CLI experience with progress indicators for long operations, verbosity controls (--verbose, --quiet, --no-color), and standard flags like --version.",
            "dependencies": [
              1
            ],
            "details": "1. Implement progress indicators:\n   - Use spinner or progress bar for long operations\n   - Show 'Building sprites [15/42]...' style output\n   - Update in-place using terminal escape codes\n   - Gracefully degrade when output is piped (no escape codes)\n\n2. Add --verbose flag:\n   - Log each file being processed\n   - Show timing information for each phase\n   - Display cache hit/miss statistics\n   - Print resolved paths and configuration\n\n3. Add --quiet flag:\n   - Suppress all non-error output\n   - Only show final success/failure\n   - Suitable for CI/CD usage\n   - Conflicts with --verbose (error if both)\n\n4. Add --version flag:\n   - Print version from embedded variable (ldflags at build)\n   - Format: 'runefact version X.Y.Z (commit: abc123)'\n   - Include build date and Go version\n\n5. Implement color control:\n   - Auto-detect terminal color support\n   - --no-color flag forces plain text\n   - RUNEFACT_NO_COLOR env var as alternative\n   - NO_COLOR standard env var support\n\n6. Update help text:\n   - Add examples for each command\n   - Group related flags\n   - Show default values",
            "status": "pending",
            "testStrategy": "1. Test --verbose produces additional output\n2. Test --quiet suppresses non-error output\n3. Test --verbose and --quiet conflict error\n4. Test --version shows expected format\n5. Test --no-color produces no ANSI codes\n6. Test NO_COLOR env var works\n7. Test progress indicators work in TTY mode"
          },
          {
            "id": 5,
            "title": "Set up GitHub Actions CI/CD for multi-platform releases",
            "description": "Create GitHub Actions workflows for continuous integration, automated testing, and multi-platform binary releases (macOS arm64/amd64, Linux amd64, Windows amd64).",
            "dependencies": [
              2,
              3
            ],
            "details": "1. Create .github/workflows/ci.yml:\n   - Trigger on push to main and pull requests\n   - Run on ubuntu-latest, macos-latest, windows-latest\n   - Steps: checkout, setup-go, go vet, go test -race\n   - Cache Go modules for faster builds\n\n2. Create .github/workflows/release.yml:\n   - Trigger on tag push (v*)\n   - Build matrix: linux/amd64, darwin/amd64, darwin/arm64, windows/amd64\n   - Use GOOS/GOARCH for cross-compilation\n   - Embed version info via ldflags\n\n3. Artifact packaging:\n   - Linux/macOS: tar.gz with binary and README\n   - Windows: zip with .exe and README\n   - Generate SHA256 checksums file\n   - Name format: runefact-VERSION-OS-ARCH.tar.gz\n\n4. Release automation:\n   - Use softprops/action-gh-release for GitHub Release\n   - Upload all binaries and checksums\n   - Auto-generate release notes from commits\n   - Mark as draft for review before publish\n\n5. Add CI badges to README:\n   - Build status badge\n   - Go Report Card badge\n   - Coverage badge (if codecov configured)\n\n6. Validate release process:\n   - Test workflow with manual trigger (workflow_dispatch)\n   - Verify all platforms produce working binaries\n   - Check artifact sizes are reasonable",
            "status": "pending",
            "testStrategy": "1. Test CI workflow runs on push and PR\n2. Test cross-compilation produces valid binaries for each platform\n3. Test version embedding works (--version shows tag)\n4. Test release artifacts have correct naming\n5. Test SHA256 checksums match binaries\n6. Manual test: download and run binaries on each platform"
          },
          {
            "id": 6,
            "title": "Complete release preparation with Homebrew, VS Code Marketplace, and documentation",
            "description": "Finalize release artifacts including Homebrew tap setup, VS Code extension publishing, comprehensive README with badges and screenshots, and CHANGELOG.md.",
            "dependencies": [
              4,
              5
            ],
            "details": "1. Set up Homebrew tap:\n   - Create runefact/homebrew-tap repository\n   - Write Formula/runefact.rb with download URLs\n   - Use pattern: versioned release assets from GitHub Releases\n   - Document: brew tap runefact/tap && brew install runefact\n\n2. VS Code extension publishing:\n   - Ensure package.json has correct metadata (publisher, version)\n   - Create VSIX package: vsce package\n   - Publish to Marketplace: vsce publish\n   - Document extension installation alternatives (VSIX, Marketplace)\n\n3. README.md enhancements:\n   - Badges: CI status, Go version, License, Release version\n   - Hero screenshot of pixel art workflow\n   - Quick start with 3-step example\n   - Feature highlights with GIFs if applicable\n   - Installation section (go install, brew, binary download)\n   - Link to full documentation\n\n4. Create CHANGELOG.md:\n   - Follow Keep a Changelog format\n   - Categories: Added, Changed, Fixed, Removed\n   - Include all features from v1.0.0\n   - Link to GitHub comparison for each version\n\n5. Final validation checklist:\n   - All tests pass on CI\n   - Demo project builds and runs\n   - MCP server responds correctly\n   - VS Code extension activates and provides diagnostics\n   - Documentation matches actual behavior\n\n6. Create GitHub Release v1.0.0:\n   - Write release notes summarizing features\n   - Attach all binary artifacts\n   - Mark as latest release",
            "status": "pending",
            "testStrategy": "1. Test Homebrew formula installs correctly\n2. Test VS Code extension installs from VSIX\n3. Verify README renders correctly on GitHub\n4. Verify all badge links work\n5. Run full validation checklist manually\n6. Test demo project builds with released binary\n7. Verify CHANGELOG follows format standards"
          }
        ]
      }
    ],
    "metadata": {
      "created": "2026-02-22T15:42:59.959Z",
      "updated": "2026-02-22T15:42:59.959Z",
      "description": "Tasks for master context"
    }
  }
}
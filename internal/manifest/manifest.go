package manifest

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"unicode"

	"github.com/vgalaktionov/runefact/internal/sprite"
)

// ManifestData aggregates all asset metadata for code generation.
type ManifestData struct {
	Package      string
	SpriteSheets []SheetEntry
	Sprites      []SpriteEntry
	Maps         []AssetEntry
	Audio        []AssetEntry
}

// SheetEntry is a sprite sheet constant.
type SheetEntry struct {
	Const string
	Path  string
}

// SpriteEntry is a sprite metadata entry.
type SpriteEntry struct {
	Key    string // "file:sprite"
	Sheet  string // constant name referencing the sheet
	X, Y   int
	W, H   int
	Frames int
	FPS    int
}

// AssetEntry is a map or audio constant.
type AssetEntry struct {
	Const string
	Path  string
}

// AddSpriteSheet adds a sprite sheet and its sprites to the manifest.
func (md *ManifestData) AddSpriteSheet(fileName string, relPath string, meta sprite.SpriteSheetMeta) {
	constName := "SpriteSheet" + ToPascalCase(strings.TrimSuffix(fileName, ".sprite"))
	md.SpriteSheets = append(md.SpriteSheets, SheetEntry{
		Const: constName,
		Path:  relPath,
	})

	baseName := strings.TrimSuffix(fileName, ".sprite")
	for name, info := range meta.Sprites {
		md.Sprites = append(md.Sprites, SpriteEntry{
			Key:    baseName + ":" + name,
			Sheet:  constName,
			X:      info.X,
			Y:      info.Y,
			W:      info.W,
			H:      info.H,
			Frames: info.Frames,
			FPS:    info.FPS,
		})
	}
}

// AddMap adds a map asset to the manifest.
func (md *ManifestData) AddMap(fileName string, relPath string) {
	constName := "Map" + ToPascalCase(strings.TrimSuffix(fileName, ".map"))
	md.Maps = append(md.Maps, AssetEntry{
		Const: constName,
		Path:  relPath,
	})
}

// AddAudio adds an audio asset to the manifest.
func (md *ManifestData) AddAudio(fileName string, relPath string) {
	name := strings.TrimSuffix(fileName, filepath.Ext(fileName))
	ext := filepath.Ext(fileName)

	var prefix string
	switch ext {
	case ".sfx":
		prefix = "SFX"
	case ".track":
		prefix = "Track"
	default:
		prefix = "Audio"
	}
	constName := prefix + ToPascalCase(name)
	md.Audio = append(md.Audio, AssetEntry{
		Const: constName,
		Path:  relPath,
	})
}

// ToPascalCase converts a string to PascalCase.
// Handles kebab-case, snake_case, and dot-separated names.
func ToPascalCase(s string) string {
	var result strings.Builder
	upper := true
	for _, r := range s {
		if r == '-' || r == '_' || r == '.' || r == ' ' {
			upper = true
			continue
		}
		if upper {
			result.WriteRune(unicode.ToUpper(r))
			upper = false
		} else {
			result.WriteRune(r)
		}
	}
	return result.String()
}

const manifestTmpl = `// Code generated by runefact. DO NOT EDIT.
package {{.Package}}

// Sprite sheets
const (
{{- range .SpriteSheets}}
	{{.Const}} = "{{.Path}}"
{{- end}}
)

// SpriteInfo holds metadata for a single sprite in a sheet.
type SpriteInfo struct {
	Sheet  string
	X, Y   int
	W, H   int
	Frames int
	FPS    int
}

// Sprites maps "file:sprite" keys to their sheet position and animation info.
var Sprites = map[string]SpriteInfo{
{{- range .Sprites}}
	"{{.Key}}": {{"{"}}{{.Sheet}}, {{.X}}, {{.Y}}, {{.W}}, {{.H}}, {{.Frames}}, {{.FPS}}{{"}"}},
{{- end}}
}

// Maps
const (
{{- range .Maps}}
	{{.Const}} = "{{.Path}}"
{{- end}}
)

// Audio
const (
{{- range .Audio}}
	{{.Const}} = "{{.Path}}"
{{- end}}
)
`

// Generate writes the manifest.go file to the given path.
func Generate(data *ManifestData, outputPath string) error {
	tmpl, err := template.New("manifest").Parse(manifestTmpl)
	if err != nil {
		return fmt.Errorf("parsing manifest template: %w", err)
	}

	if err := os.MkdirAll(filepath.Dir(outputPath), 0755); err != nil {
		return fmt.Errorf("creating output directory: %w", err)
	}

	f, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("creating manifest file: %w", err)
	}
	defer f.Close()

	if err := tmpl.Execute(f, data); err != nil {
		return fmt.Errorf("executing manifest template: %w", err)
	}

	return nil
}
